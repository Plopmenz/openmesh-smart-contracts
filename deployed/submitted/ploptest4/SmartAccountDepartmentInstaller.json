{
  "type": "deployment",
  "id": "SmartAccountDepartmentInstaller",
  "batch": "ploptest4",
  "batchIndex": 42,
  "deploymentAddress": "0x361d3799e3890627bb1b30AaF44eB84c7F5DB91C",
  "constructorArgs": [
    "0x9478eaab9F531533487c220C451820c3c7901e6b",
    "0x4087CdEC13559B75428BE770e9799f2F02d21CaE",
    "0xA4C53225d7A3acE458Ec7FD25527072c01a8c95E",
    "0x4410ec298412DDeeC7D5cd6d9B8271Ac6445A96e",
    "0x52a7E7C9EB8d92BdFC3B08550EDC8B1f7Eb5fE47"
  ],
  "to": "0x4e59b44847b379578588920ca78fbf26c0b4956c",
  "value": "0",
  "data": "0x0000000000000000000000000000000000000000000000706c6f707465737434610120346100f657601f61071f38819003918201601f19168301916001600160401b038311848410176100fa5780849260a0946040528339810103126100f65780516001600160a01b03919082811681036100f6576100606020830161010e565b61006c6040840161010e565b9160608401519385851685036100f6576080015194851685036100f65760805260a05260c05260e0526101009081526040516105fc918261012383396080518281816101010152610194015260a05182818161028e01526104ff015260c05182818160be01526102bb015260e051828181607701526102e701525181818161014401526104100152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b51906001600160a01b03821682036100f65756fe6080604081815260049182361015610015575f80fd5b5f925f3560e01c91826306bdef16146104ed5750816312f8740a14610173575080632016061e1461013057806335ece072146100ed5780637ae0d914146100aa5763eb85ce6014610064575f80fd5b346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b50346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b8383346104e95760203660031901126104e95782359060018060a01b0390817f0000000000000000000000000000000000000000000000000000000000000000167f0e1b22cdaccd652db85cbcd4ee8f705beabfaa30664122ccc544137ef20749bb826331c6fcc960e21b92835f527f56a2f102f06100e6e9193cce9cca60c6a83719df4146213240bdd4963e5931ba602052815f20816bffffffffffffffffffffffff60a01b8254161790558151908482526020820152a1805f527f1164ff701c332a936c6fdd0cee9b71313a2f7a4aebd6e4eb4e5f25a54a3bd7d7602052815f20600160ff198254161790557f0ec03a921b5deb73a9948473b4744dde91adeb598eacc1fca09623171feafb3e6020835160018152a2817f000000000000000000000000000000000000000000000000000000000000000016946102b886610556565b827f0000000000000000000000000000000000000000000000000000000000000000166102e481610556565b837f00000000000000000000000000000000000000000000000000000000000000001690873b156104e957835163d45cfee960e01b80825230858301526024820188905260448201849052634e8cbc7160e11b606483015260848201879052905f8160a481838e5af180156104df576104ca575b50978798819897983b156104c657879160a48392885194859384928352308a8401528d602484015288604484015263f4a523c560e01b60648401528b60848401525af180156104a8579087916104b2575b5050813b15610490578351632a9ce78b60e01b8152308482015262093a806024820152868160448183875af180156104a857908791610494575b5050803b15610490578592836084928651978895869463dbe90fd160e01b865230908601526024850152807f000000000000000000000000000000000000000000000000000000000000000016604485015260648401525af19081156104875750610473575b5050307f7632a4db40e324590a2ab64b0fac5213ef88244092ffd0ca76d75324e7af70708380a380f35b61047c9061052e565b6100a6578183610449565b513d84823e3d90fd5b8580fd5b61049d9061052e565b6104905785896103e3565b85513d89823e3d90fd5b6104bb9061052e565b6104905785896103a9565b8780fd5b6104d69197985061052e565b5f969589610358565b86513d5f823e3d90fd5b5f80fd5b346104e9575f3660031901126104e9577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b67ffffffffffffffff811161054257604052565b634e487b7160e01b5f52604160045260245ffd5b60407f34051a60a9aba6f1aab675ea08454fec104dde53056b328a8578b589e2a3a6679160018060a01b0316805f527f6773380c68a4f1b5fc0767331b3f78df01c93053a8577bbdc258bc2fa4d79a4a602052815f20600160ff19825416179055815190815260016020820152a156fea2646970667358221220c44eb12f4d4d9f3f27c0d84ae62301384a08a7e019d02a2d47d8826d8175455a64736f6c634300081700330000000000000000000000009478eaab9f531533487c220c451820c3c7901e6b0000000000000000000000004087cdec13559b75428be770e9799f2f02d21cae000000000000000000000000a4c53225d7a3ace458ec7fd25527072c01a8c95e0000000000000000000000004410ec298412ddeec7d5cd6d9b8271ac6445a96e00000000000000000000000052a7e7c9eb8d92bdfc3b08550edc8b1f7eb5fe47",
  "gas": "393313",
  "from": "0xaF7E68bCb2Fc7295492A00177f14F59B92814e70",
  "transactionSettings": {
    "chainId": 80001,
    "nonce": "700",
    "baseFee": "1500000000",
    "priorityFee": "1500000000"
  },
  "salt": "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ploptest4",
  "artifact": {
    "abi": [
      {
        "type": "constructor",
        "inputs": [
          {
            "name": "_smartAccountTrustlessExecution",
            "type": "address",
            "internalType": "contract ISmartAccountTrustlessExecution"
          },
          {
            "name": "_tagTrustlessManagement",
            "type": "address",
            "internalType": "contract ITrustlessManagement"
          },
          {
            "name": "_addressTrustlessManagement",
            "type": "address",
            "internalType": "contract ITrustlessManagement"
          },
          {
            "name": "_optimisticActions",
            "type": "address",
            "internalType": "contract IOptimisticActions"
          },
          { "name": "_openRD", "type": "address", "internalType": "address" }
        ],
        "stateMutability": "nonpayable"
      },
      {
        "type": "function",
        "name": "addressTrustlessManagement",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "address",
            "internalType": "contract ITrustlessManagement"
          }
        ],
        "stateMutability": "view"
      },
      {
        "type": "function",
        "name": "install",
        "inputs": [
          { "name": "_tag", "type": "bytes32", "internalType": "bytes32" }
        ],
        "outputs": [],
        "stateMutability": "nonpayable"
      },
      {
        "type": "function",
        "name": "openRD",
        "inputs": [],
        "outputs": [
          { "name": "", "type": "address", "internalType": "address" }
        ],
        "stateMutability": "view"
      },
      {
        "type": "function",
        "name": "optimisticActions",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "address",
            "internalType": "contract IOptimisticActions"
          }
        ],
        "stateMutability": "view"
      },
      {
        "type": "function",
        "name": "smartAccountTrustlessExecution",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "address",
            "internalType": "contract ISmartAccountTrustlessExecution"
          }
        ],
        "stateMutability": "view"
      },
      {
        "type": "function",
        "name": "tagTrustlessManagement",
        "inputs": [],
        "outputs": [
          {
            "name": "",
            "type": "address",
            "internalType": "contract ITrustlessManagement"
          }
        ],
        "stateMutability": "view"
      },
      {
        "type": "event",
        "name": "DepartmentInstalled",
        "inputs": [
          {
            "name": "department",
            "type": "address",
            "indexed": true,
            "internalType": "address"
          },
          {
            "name": "tag",
            "type": "bytes32",
            "indexed": true,
            "internalType": "bytes32"
          }
        ],
        "anonymous": false
      },
      {
        "type": "event",
        "name": "ExecutePermissionSet",
        "inputs": [
          {
            "name": "account",
            "type": "address",
            "indexed": false,
            "internalType": "address"
          },
          {
            "name": "allowed",
            "type": "bool",
            "indexed": false,
            "internalType": "bool"
          }
        ],
        "anonymous": false
      },
      {
        "type": "event",
        "name": "InterfaceSupportedChanged",
        "inputs": [
          {
            "name": "interfaceId",
            "type": "bytes4",
            "indexed": true,
            "internalType": "bytes4"
          },
          {
            "name": "supported",
            "type": "bool",
            "indexed": false,
            "internalType": "bool"
          }
        ],
        "anonymous": false
      },
      {
        "type": "event",
        "name": "ModuleSet",
        "inputs": [
          {
            "name": "functionSelector",
            "type": "bytes4",
            "indexed": false,
            "internalType": "bytes4"
          },
          {
            "name": "module",
            "type": "address",
            "indexed": false,
            "internalType": "address"
          }
        ],
        "anonymous": false
      }
    ],
    "bytecode": "0x610120346100f657601f61071f38819003918201601f19168301916001600160401b038311848410176100fa5780849260a0946040528339810103126100f65780516001600160a01b03919082811681036100f6576100606020830161010e565b61006c6040840161010e565b9160608401519385851685036100f6576080015194851685036100f65760805260a05260c05260e0526101009081526040516105fc918261012383396080518281816101010152610194015260a05182818161028e01526104ff015260c05182818160be01526102bb015260e051828181607701526102e701525181818161014401526104100152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b51906001600160a01b03821682036100f65756fe6080604081815260049182361015610015575f80fd5b5f925f3560e01c91826306bdef16146104ed5750816312f8740a14610173575080632016061e1461013057806335ece072146100ed5780637ae0d914146100aa5763eb85ce6014610064575f80fd5b346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5080fd5b50346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100a657816003193601126100a657517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b8383346104e95760203660031901126104e95782359060018060a01b0390817f0000000000000000000000000000000000000000000000000000000000000000167f0e1b22cdaccd652db85cbcd4ee8f705beabfaa30664122ccc544137ef20749bb826331c6fcc960e21b92835f527f56a2f102f06100e6e9193cce9cca60c6a83719df4146213240bdd4963e5931ba602052815f20816bffffffffffffffffffffffff60a01b8254161790558151908482526020820152a1805f527f1164ff701c332a936c6fdd0cee9b71313a2f7a4aebd6e4eb4e5f25a54a3bd7d7602052815f20600160ff198254161790557f0ec03a921b5deb73a9948473b4744dde91adeb598eacc1fca09623171feafb3e6020835160018152a2817f000000000000000000000000000000000000000000000000000000000000000016946102b886610556565b827f0000000000000000000000000000000000000000000000000000000000000000166102e481610556565b837f00000000000000000000000000000000000000000000000000000000000000001690873b156104e957835163d45cfee960e01b80825230858301526024820188905260448201849052634e8cbc7160e11b606483015260848201879052905f8160a481838e5af180156104df576104ca575b50978798819897983b156104c657879160a48392885194859384928352308a8401528d602484015288604484015263f4a523c560e01b60648401528b60848401525af180156104a8579087916104b2575b5050813b15610490578351632a9ce78b60e01b8152308482015262093a806024820152868160448183875af180156104a857908791610494575b5050803b15610490578592836084928651978895869463dbe90fd160e01b865230908601526024850152807f000000000000000000000000000000000000000000000000000000000000000016604485015260648401525af19081156104875750610473575b5050307f7632a4db40e324590a2ab64b0fac5213ef88244092ffd0ca76d75324e7af70708380a380f35b61047c9061052e565b6100a6578183610449565b513d84823e3d90fd5b8580fd5b61049d9061052e565b6104905785896103e3565b85513d89823e3d90fd5b6104bb9061052e565b6104905785896103a9565b8780fd5b6104d69197985061052e565b5f969589610358565b86513d5f823e3d90fd5b5f80fd5b346104e9575f3660031901126104e9577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b67ffffffffffffffff811161054257604052565b634e487b7160e01b5f52604160045260245ffd5b60407f34051a60a9aba6f1aab675ea08454fec104dde53056b328a8578b589e2a3a6679160018060a01b0316805f527f6773380c68a4f1b5fc0767331b3f78df01c93053a8577bbdc258bc2fa4d79a4a602052815f20600160ff19825416179055815190815260016020820152a156fea2646970667358221220c44eb12f4d4d9f3f27c0d84ae62301384a08a7e019d02a2d47d8826d8175455a64736f6c63430008170033",
    "compiler": { "version": "v0.8.23+commit.f704f362" },
    "contractName": "src/SmartAccountDepartmentInstaller.sol:SmartAccountDepartmentInstaller",
    "jsonDescription": {
      "language": "Solidity",
      "sources": {
        "lib/smart-account/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
          "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "lib/smart-account/src/modules/ISmartAccountModules.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISmartAccountModules {\n    /// @notice When no function exists for function called\n    error FunctionNotFound(bytes4 functionSelector);\n\n    /// @notice Module is added/updated/removed.\n    event ModuleSet(bytes4 functionSelector, address module);\n\n    /// @notice Set the currently registered module for function.\n    /// @dev Zero address means no module is registered.\n    function getModule(bytes4 functionSelector) external view returns (address module);\n}\n"
        },
        "lib/smart-account/src/modules/SmartAccountModulesLib.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SmartAccountERC165Lib} from \"./erc165/SmartAccountERC165Lib.sol\";\n\nimport {ISmartAccountModules} from \"./ISmartAccountModules.sol\";\n\n// Inspired by ERC-2535\nlibrary SmartAccountModulesLib {\n    bytes32 constant STORAGE_POSITION = keccak256(\"modules.smartaccount.plopmenz\");\n\n    struct Storage {\n        mapping(bytes4 functionSelector => address module) getFunction;\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /// @notice Sets the interfaces implemented by this contract to (un)supported.\n    function setInterfaces(bool supported) internal {\n        SmartAccountERC165Lib.setInterfaceSupport(type(ISmartAccountModules).interfaceId, supported);\n    }\n\n    /// @notice Installs all functions, interfaces, and performs storage initialization of this module.\n    function fullInstall(address module) internal {\n        setModule(ISmartAccountModules.getModule.selector, module);\n        setInterfaces(true);\n    }\n\n    /// @notice Uninstalls all functions and interfaces of this module.\n    function fullUninstall() internal {\n        setModule(ISmartAccountModules.getModule.selector, address(0));\n        setInterfaces(false);\n    }\n\n    /// @notice Get the currently registered module for function.\n    function getModule(bytes4 functionSelector) internal view returns (address module) {\n        return getStorage().getFunction[functionSelector];\n    }\n\n    /// @notice Set the currently registered module for function.\n    /// @dev Set to zero address to remove.\n    function setModule(bytes4 functionSelector, address module) internal {\n        getStorage().getFunction[functionSelector] = module;\n        emit ISmartAccountModules.ModuleSet(functionSelector, module);\n    }\n\n    /// @notice Delegates the current msg call to a module, if one is registered for that function.\n    function callModule() internal {\n        // Get module from function selector\n        address module = getModule(msg.sig);\n        if (module == address(0)) {\n            revert ISmartAccountModules.FunctionNotFound(msg.sig);\n        }\n        // Execute external function from module using delegatecall and return any value.\n        assembly {\n            // Copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // Execute function call using the module\n            let result := delegatecall(gas(), module, 0, calldatasize(), 0, 0)\n            // Get any return value\n            returndatacopy(0, 0, returndatasize())\n            // Return any return value or error back to the caller\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n"
        },
        "lib/smart-account/src/modules/erc165/ISmartAccountERC165.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"../../../lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\";\n\ninterface ISmartAccountERC165 is IERC165 {\n    /// @notice Interface support changed.\n    event InterfaceSupportedChanged(bytes4 indexed interfaceId, bool supported);\n}\n"
        },
        "lib/smart-account/src/modules/erc165/SmartAccountERC165Lib.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SmartAccountModulesLib} from \"../SmartAccountModulesLib.sol\";\n\nimport {ISmartAccountERC165, IERC165} from \"./ISmartAccountERC165.sol\";\n\nlibrary SmartAccountERC165Lib {\n    bytes32 constant STORAGE_POSITION = keccak256(\"erc165.modules.smartaccount.plopmenz\");\n\n    struct Storage {\n        mapping(bytes4 interfaceId => bool supported) getSupported;\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /// @notice Installs all functions, interfaces, and performs storage initialization of this module.\n    function fullInstall(address module) internal {\n        SmartAccountModulesLib.setModule(IERC165.supportsInterface.selector, module);\n    }\n\n    /// @notice Uninstalls all functions and interfaces of this module.\n    function fullUninstall() internal {\n        SmartAccountModulesLib.setModule(IERC165.supportsInterface.selector, address(0));\n    }\n\n    /// @notice Gets the interfaces supported by the Smart Account.\n    function supportsInterface(bytes4 interfaceId) internal view returns (bool supported) {\n        return getStorage().getSupported[interfaceId];\n    }\n\n    /// @notice Updates the interfaces supported by the Smart Account.\n    function setInterfaceSupport(bytes4 interfaceId, bool supported) internal {\n        getStorage().getSupported[interfaceId] = supported;\n        emit ISmartAccountERC165.InterfaceSupportedChanged(interfaceId, supported);\n    }\n}\n"
        },
        "lib/smart-account/src/modules/trustless-execution/ISmartAccountTrustlessExecution.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISmartAccountTrustlessExecution {\n    /// @notice The caller account is not authorized to perform an operation.\n    error NoExecutePermission(address account);\n\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\n    error TooManyActions();\n\n    /// @notice Thrown if action execution has failed.\n    /// @param index The index of the action in the action array that failed.\n    error ActionFailed(uint256 index);\n\n    /// @notice Thrown if an action has insufficent gas left.\n    error InsufficientGas();\n\n    /// @notice A (new) account has become the owner of this contract.\n    event ExecutePermissionSet(address account, bool allowed);\n\n    /// @notice Emitted when an execution is performed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return execResults The array of results obtained from the executed actions in `bytes`.\n    /// @return failureMap The resulting failure map containing the actions have actually failed.\n    function execute(bytes32 _callId, Action[] memory _actions, uint256 _allowFailureMap)\n        external\n        returns (bytes[] memory execResults, uint256 failureMap);\n}\n"
        },
        "lib/smart-account/src/modules/trustless-execution/SmartAccountTrustlessExecutionLib.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SmartAccountERC165Lib} from \"../erc165/SmartAccountERC165Lib.sol\";\nimport {SmartAccountModulesLib} from \"../SmartAccountModulesLib.sol\";\n\nimport {ISmartAccountTrustlessExecution} from \"./ISmartAccountTrustlessExecution.sol\";\n\nuint256 constant MAX_ACTIONS = 256;\n\nlibrary SmartAccountTrustlessExecutionLib {\n    bytes32 constant STORAGE_POSITION = keccak256(\"execution.trustless.modules.smartaccount.plopmenz\");\n\n    struct Storage {\n        mapping(address executor => bool allowed) executePermission;\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /// @notice Sets the interfaces implemented by this contract to (un)supported.\n    function setInterfaces(bool supported) internal {\n        SmartAccountERC165Lib.setInterfaceSupport(type(ISmartAccountTrustlessExecution).interfaceId, supported);\n    }\n\n    /// @notice Installs all functions, interfaces, and performs storage initialization of this module.\n    function fullInstall(address module) internal {\n        SmartAccountModulesLib.setModule(ISmartAccountTrustlessExecution.execute.selector, module);\n        setInterfaces(true);\n    }\n\n    /// @notice Uninstalls all functions and interfaces of this module.\n    function fullUninstall() internal {\n        SmartAccountModulesLib.setModule(ISmartAccountTrustlessExecution.execute.selector, address(0));\n        setInterfaces(false);\n    }\n\n    /// @notice Reverts if `account` is not allowed to execute actions for this smart account.\n    function ensureHasExecutePermission(address account) internal view {\n        if (!getStorage().executePermission[account]) {\n            revert ISmartAccountTrustlessExecution.NoExecutePermission(account);\n        }\n    }\n\n    /// @notice Sets if `account` is allowed to execute actions for this smart account.\n    function setExecutePermission(address account, bool allowed) internal {\n        getStorage().executePermission[account] = allowed;\n        emit ISmartAccountTrustlessExecution.ExecutePermissionSet(account, allowed);\n    }\n\n    /// Source: https://github.com/aragon/osx/blob/develop/packages/contracts/src/core/dao/DAO.sol\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return execResults The array of results obtained from the executed actions in `bytes`.\n    /// @return failureMap The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        ISmartAccountTrustlessExecution.Action[] calldata _actions,\n        uint256 _allowFailureMap\n    ) internal returns (bytes[] memory execResults, uint256 failureMap) {\n        ensureHasExecutePermission(msg.sender);\n\n        // Check that the action array length is within bounds.\n        if (_actions.length > MAX_ACTIONS) {\n            revert ISmartAccountTrustlessExecution.TooManyActions();\n        }\n\n        execResults = new bytes[](_actions.length);\n\n        uint256 gasBefore;\n        uint256 gasAfter;\n\n        for (uint256 i = 0; i < _actions.length;) {\n            gasBefore = gasleft();\n\n            (bool success, bytes memory result) = _actions[i].to.call{value: _actions[i].value}(_actions[i].data);\n            gasAfter = gasleft();\n\n            // Check if failure is allowed\n            if (!hasBit(_allowFailureMap, uint8(i))) {\n                // Check if the call failed.\n                if (!success) {\n                    revert ISmartAccountTrustlessExecution.ActionFailed(i);\n                }\n            } else {\n                // Check if the call failed.\n                if (!success) {\n                    // Make sure that the action call did not fail because 63/64 of `gasleft()` was insufficient to execute the external call `.to.call` (see [ERC-150](https://eips.ethereum.org/EIPS/eip-150)).\n                    // In specific scenarios, i.e. proposal execution where the last action in the action array is allowed to fail, the account calling `execute` could force-fail this action by setting a gas limit\n                    // where 63/64 is insufficient causing the `.to.call` to fail, but where the remaining 1/64 gas are sufficient to successfully finish the `execute` call.\n                    if (gasAfter < gasBefore / 64) {\n                        revert ISmartAccountTrustlessExecution.InsufficientGas();\n                    }\n\n                    // Store that this action failed.\n                    failureMap = flipBit(failureMap, uint8(i));\n                }\n            }\n\n            execResults[i] = result;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ISmartAccountTrustlessExecution.Executed({\n            actor: msg.sender,\n            callId: _callId,\n            actions: _actions,\n            allowFailureMap: _allowFailureMap,\n            failureMap: failureMap,\n            execResults: execResults\n        });\n    }\n\n    /// Source: https://github.com/aragon/osx-commons/blob/develop/contracts/src/utils/math/BitMap.sol\n    /// @param bitmap The `uint256` representation of bits.\n    /// @param index The index number to check whether 1 or 0 is set.\n    /// @return Returns `true` if the bit is set at `index` on `bitmap`.\n    function hasBit(uint256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 bitValue = bitmap & (1 << index);\n        return bitValue > 0;\n    }\n\n    /// Source: https://github.com/aragon/osx-commons/blob/develop/contracts/src/utils/math/BitMap.sol\n    /// @param bitmap The `uint256` representation of bits.\n    /// @param index The index number to set the bit.\n    /// @return Returns a new number in which the bit is set at `index`.\n    function flipBit(uint256 bitmap, uint8 index) internal pure returns (uint256) {\n        return bitmap ^ (1 << index);\n    }\n}\n"
        },
        "lib/trustless-actions/lib/trustless-management/lib/osx-commons/contracts/src/dao/IDAO.sol": {
          "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IDAO\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\n/// @custom:security-contact sirt@aragon.org\ninterface IDAO {\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return The array of results obtained from the executed actions in `bytes`.\n    /// @return The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) external returns (bytes[] memory, uint256);\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external view returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Checks whether a signature is valid for a provided hash according to [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271).\n    /// @param _hash The hash of the data to be signed.\n    /// @param _signature The signature byte array associated with `_hash`.\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid and `0xffffffff` if not.\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external;\n\n    /// @notice Removed function being left here to not corrupt the IDAO interface ID. Any call will revert.\n    /// @dev Introduced in v1.0.0. Removed in v1.4.0.\n    function setSignatureValidator(address) external;\n}\n"
        },
        "lib/trustless-actions/lib/trustless-management/src/IDAOExtensionWithAdmin.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAO} from \"../lib/osx-commons/contracts/src/dao/IDAO.sol\";\n\ninterface IDAOExtensionWithAdmin {\n    error SenderIsNotAdmin();\n\n    event AdminSet(IDAO indexed dao, address admin);\n\n    /// @notice Registers or updates the admin of a DAO. The admin has the permission to change permissions.\n    /// @param _dao The DAO this admin will control.\n    /// @param _admin The address that will control the DAO.\n    /// @dev If no admin is set, this can only be called by the DAO itself. When an admin is set, only the existing admin can update.\n    function setAdmin(IDAO _dao, address _admin) external;\n}\n"
        },
        "lib/trustless-actions/lib/trustless-management/src/IDAOManager.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOExtensionWithAdmin, IDAO} from \"./IDAOExtensionWithAdmin.sol\";\n\ninterface IDAOManager is IDAOExtensionWithAdmin {\n    error AccessDenied();\n\n    event Execution(\n        IDAO indexed dao,\n        uint256 indexed role,\n        address indexed sender,\n        IDAO.Action[] actions,\n        bytes[] returnValues,\n        uint256 failureMap\n    );\n\n    /// @notice Executes a list of actions as the DAO.\n    /// @param _dao Which DAO should execute the actions.\n    /// @param _role The role to use for validation if execution is allowed.\n    /// @param _actions The actions to execute.\n    /// @param _failureMap Which actions are allowed to fail without reverting the whole transaction.\n    /// @dev Only a single role means that a user satisfies multiple roles they might need to split their actions into multiple batches (one per role).\n    function asDAO(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions, uint256 _failureMap)\n        external\n        returns (bytes[] memory returnValues, uint256 failureMap);\n}\n"
        },
        "lib/trustless-actions/src/IOptimisticActions.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOExtensionWithAdmin} from \"../lib/trustless-management/src/IDAOExtensionWithAdmin.sol\";\nimport {ITrustlessActions, IDAOManager, IDAO} from \"./ITrustlessActions.sol\";\n\ninterface IOptimisticActions is ITrustlessActions, IDAOExtensionWithAdmin {\n    error OptimisticRequestNotExecutableYet();\n\n    event OptimisticActionCreated(uint32 indexed id, IDAO indexed dao, uint64 executableFrom);\n    event OptimisticActionRejected(uint32 indexed id, IDAO indexed dao, string metadata);\n    event OptimisticExecuteDelaySet(IDAO indexed dao, uint64 executeDelay);\n\n    /// @notice A container for all optimistic settings related to a certain DAO.\n    /// @param admin The address that can change the settings for this DAO. Default address(0) means the DAO itself.\n    /// @param executeDelay How long actions need to wait before they become executable (if not rejected before).\n    struct OptimisticDAOSettings {\n        address admin;\n        uint64 executeDelay;\n    }\n\n    /// @notice A container for all info related to an optimistic execute action request.\n    /// @param executableFrom From what block time the request becomes executable.\n    struct OptimisticActionRequest {\n        uint64 executableFrom;\n    }\n\n    /// @notice Gets a certain optimstic action request.\n    /// @param _dao The DAO that has the request.\n    /// @param _id The id of the request.\n    function getOptimsticAction(IDAO _dao, uint32 _id) external view returns (OptimisticActionRequest memory request);\n\n    /// @notice Rejects a certain action request. The sender should be the DAO (utilizing a management solution).\n    /// @param _id The id of the request.\n    /// @param _metadata Additional info from the rejector.\n    function rejectAction(uint32 _id, string calldata _metadata) external;\n\n    /// @notice Changes the execute delay of a DAO.\n    /// @param _dao The DAO to change the settings of.\n    /// @param _executeDelay The new execute delay.\n    /// @dev By default this value is 0, meaning there is no delay. This is likely not desired so you are recommened to set the delay before granting this contract any permissions.\n    function setExecuteDelay(IDAO _dao, uint64 _executeDelay) external;\n}\n"
        },
        "lib/trustless-actions/src/ITrustlessActions.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOManager, IDAO} from \"../lib/trustless-management/src/IDAOManager.sol\";\n\ninterface ITrustlessActions {\n    error RequestDoesNotExist();\n    error RequestAlreadyExecuted();\n\n    event ActionCreated(\n        uint32 indexed id,\n        IDAO indexed dao,\n        IDAOManager manager,\n        uint256 role,\n        IDAO.Action[] actions,\n        uint256 failureMap,\n        string metadata\n    );\n    event ActionExecuted(\n        uint32 indexed id, IDAO indexed dao, address indexed executor, bytes[] returnValues, uint256 failureMap\n    );\n\n    /// @notice A container for multiple requests.\n    /// @param requestCount How many proposed actions have been created.\n    /// @param getRequest The proposed actions to be executed.\n    struct ActionRequests {\n        uint32 requestCount;\n        mapping(uint32 id => ActionRequest request) getRequest;\n    }\n\n    /// @notice A container for all info related to an execute action request.\n    /// @param executed If the action has been executed.\n    /// @param manager The management contract to use for the execution.\n    /// @param role The role to use for the execution.\n    /// @param actions The actions to execute.\n    /// @param failureMap Which actions are allowed to fail without reverting the transaction.\n    struct ActionRequest {\n        bool executed;\n        IDAOManager manager;\n        uint256 role;\n        IDAO.Action[] actions;\n        uint256 failureMap;\n    }\n\n    /// @notice Gets a certain action request.\n    /// @param _dao The DAO that has the request.\n    /// @param _id The id of the request.\n    function getAction(IDAO _dao, uint32 _id) external view returns (ActionRequest memory request);\n\n    /// @notice Creates a request to execute certain actions.\n    /// @param _manager The management contract to use for performing the actions.\n    /// @param _role The role of the management contract to use for performing the actions.\n    /// @param _actions The actions that are proposed to be executed.\n    /// @param _failureMap The actions that are allowed to be revert.\n    /// @param _metadata Additional info from the creator.\n    /// @dev The sender should be the DAO (utilizing a management solution).\n    function createAction(\n        IDAOManager _manager,\n        uint256 _role,\n        IDAO.Action[] calldata _actions,\n        uint256 _failureMap,\n        string calldata _metadata\n    ) external returns (uint32 id);\n\n    /// @notice Executes a certain action request.\n    /// @param _dao The DAO that has the request.\n    /// @param _id The id of the request.\n    /// @dev This is only possible if the request has not been executed yet and the conditions of the TrustlessActions implementation are met.\n    function executeAction(IDAO _dao, uint32 _id) external returns (bytes[] memory returnValues, uint256 failureMap);\n}\n"
        },
        "lib/trustless-management/lib/ens-reverse-claimable/src/ENSReverseClaimable.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSReverseClaimable {\n    /// @notice ENS reverse name resolution is claimable by the owner of the contract.\n    function owner() external pure virtual returns (address) {\n        return 0xaF7E68bCb2Fc7295492A00177f14F59B92814e70; // plopmenz.eth\n    }\n}\n"
        },
        "lib/trustless-management/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
          "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
        },
        "lib/trustless-management/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
          "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
        },
        "lib/trustless-management/lib/osx-commons/contracts/src/dao/IDAO.sol": {
          "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IDAO\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\n/// @custom:security-contact sirt@aragon.org\ninterface IDAO {\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return The array of results obtained from the executed actions in `bytes`.\n    /// @return The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) external returns (bytes[] memory, uint256);\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external view returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Checks whether a signature is valid for a provided hash according to [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271).\n    /// @param _hash The hash of the data to be signed.\n    /// @param _signature The signature byte array associated with `_hash`.\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid and `0xffffffff` if not.\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external;\n\n    /// @notice Removed function being left here to not corrupt the IDAO interface ID. Any call will revert.\n    /// @dev Introduced in v1.0.0. Removed in v1.4.0.\n    function setSignatureValidator(address) external;\n}\n"
        },
        "lib/trustless-management/src/IDAOExtensionWithAdmin.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAO} from \"../lib/osx-commons/contracts/src/dao/IDAO.sol\";\n\ninterface IDAOExtensionWithAdmin {\n    error SenderIsNotAdmin();\n\n    event AdminSet(IDAO indexed dao, address admin);\n\n    /// @notice Registers or updates the admin of a DAO. The admin has the permission to change permissions.\n    /// @param _dao The DAO this admin will control.\n    /// @param _admin The address that will control the DAO.\n    /// @dev If no admin is set, this can only be called by the DAO itself. When an admin is set, only the existing admin can update.\n    function setAdmin(IDAO _dao, address _admin) external;\n}\n"
        },
        "lib/trustless-management/src/IDAOManager.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOExtensionWithAdmin, IDAO} from \"./IDAOExtensionWithAdmin.sol\";\n\ninterface IDAOManager is IDAOExtensionWithAdmin {\n    error AccessDenied();\n\n    event Execution(\n        IDAO indexed dao,\n        uint256 indexed role,\n        address indexed sender,\n        IDAO.Action[] actions,\n        bytes[] returnValues,\n        uint256 failureMap\n    );\n\n    /// @notice Executes a list of actions as the DAO.\n    /// @param _dao Which DAO should execute the actions.\n    /// @param _role The role to use for validation if execution is allowed.\n    /// @param _actions The actions to execute.\n    /// @param _failureMap Which actions are allowed to fail without reverting the whole transaction.\n    /// @dev Only a single role means that a user satisfies multiple roles they might need to split their actions into multiple batches (one per role).\n    function asDAO(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions, uint256 _failureMap)\n        external\n        returns (bytes[] memory returnValues, uint256 failureMap);\n}\n"
        },
        "lib/trustless-management/src/IPermissionChecker.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAO} from \"../lib/osx-commons/contracts/src/dao/IDAO.sol\";\n\ninterface IPermissionChecker {\n    /// @notice Additional external check if custom conditions are met.\n    /// @param _role The role to check permission for. (this could represent address / holding x amount of ERC20 tokens / ERC721 tokenId / ERC1155 tokenId)\n    /// @param _action The action to check.\n    function checkPermission(uint256 _role, IDAO.Action calldata _action) external view returns (bool);\n}\n"
        },
        "lib/trustless-management/src/ITrustlessManagement.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOManager, IDAO, IDAOExtensionWithAdmin} from \"./IDAOManager.sol\";\n\ninterface ITrustlessManagement is IDAOManager {\n    error SenderDoesNotHaveRole();\n\n    event FunctionBlacklistChanged(\n        IDAO indexed dao, uint256 indexed role, address zone, bytes4 functionSelector, address permissionChecker\n    );\n    event ZoneBlacklistChanged(IDAO indexed dao, uint256 indexed role, address zone, address permissionChecker);\n    event FullAccessChanged(IDAO indexed dao, uint256 indexed role, address permissionChecker);\n    event ZoneAccessChanged(IDAO indexed dao, uint256 indexed role, address zone, address permissionChecker);\n    event FunctionAccessChanged(\n        IDAO indexed dao, uint256 indexed role, address zone, bytes4 functionSelector, address permissionChecker\n    );\n\n    /// @notice A container for all info related to a certain DAO.\n    /// @param admin The address that can change the permissions for this DAO.\n    /// @param permissions The permissions set for this DAO.\n    /// @dev Admin as zero address / unset means that the DAO will be the admin itself.\n    struct DAOInfo {\n        address admin;\n        mapping(uint256 role => PermissionInfo permission) permissions;\n    }\n\n    /// @notice A container for all info related to the permissions of a certain role.\n    /// @param fullAccess This role has access to perform any actions, the address referes to a permissionChecker that can be used to impose restrictions.\n    /// @param zoneAccess This role has access to perform any actions, as long as its with a certain smart contract address (zone).\n    /// @param zoneBlacklist This role is prevented to perform any actions with a certain smart contract address (zone).\n    /// @param functionAccess This role has access to call a specific function (functionSelector) of a certain smart contract address (zone).\n    /// @param functionBlacklist This role is prevented to call a specific function (functionSelector) of a certain smart contract address (zone).\n    /// @dev In case you dont need to use any permissionChecker, you can set the address to NO_PERMISSION_CHECKER = address(type(uint160).max).\n    /// @dev In case you want to revoke the permission, you can set the permissionChecker back to default REVOKE = address(0).\n    /// @dev FunctionIds are encoded as (uint160(bytes20(_zone)) << 32) + uint32(_functionSelector).\n    struct PermissionInfo {\n        address fullAccess;\n        mapping(address zone => address permissionChecker) zoneAccess;\n        mapping(address zone => address permissionChecker) zoneBlacklist;\n        mapping(uint256 functionId => address permissionChecker) functionAccess;\n        mapping(uint256 functionId => address permissionChecker) functionBlacklist;\n    }\n\n    /// @notice Verifies if an address has/satisfies a certain role.\n    /// @param _account The address to check.\n    /// @param _roleId The role to check.\n    function hasRole(address _account, uint256 _roleId) external view returns (bool);\n\n    /// @notice Verifies if a role is allowed to execute a list of actions.\n    /// @param _dao The DAO to check permissions of.\n    /// @param _role The role to check permission for.\n    /// @param _actions The actions to check.\n    /// @dev Only a single role means that a user satisfies multiple roles they might need to split their actions into multiple batches (one per role).\n    function isAllowed(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions) external view returns (bool);\n\n    /// @notice Grants/Revokes a role the permission to do any action (if not blacklisted).\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is granted/revoked the permission.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    function changeFullAccess(IDAO _dao, uint256 _role, address _permissionChecker) external;\n\n    /// @notice Grants/Revokes a role the permission to call all functions of one smart contract (if not blacklisted).\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is granted/revoked the permission.\n    /// @param _zone The address of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    function changeZoneAccess(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external;\n\n    /// @notice Adds to / Removes from a blacklist preventing a role from calling one function of one smart contract.\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is added to / removed from this blacklist.\n    /// @param _zone The address of the smart contract.\n    /// @param _functionSelector The function selector of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    /// @dev This takes priority no matter what access (full/zone/function) the role has.\n    function changeFunctionBlacklist(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external;\n\n    /// @notice Grants/Revokes a role the permission to call one function of one smart contract (if not blacklisted).\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is granted/revoked the permission.\n    /// @param _zone The address of the smart contract.\n    /// @param _functionSelector The function selector of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    function changeFunctionAccess(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external;\n\n    /// @notice Adds to / Removes from a blacklist preventing a role from calling any function of one smart contract.\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is added to / removed from this blacklist.\n    /// @param _zone The address of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    /// @dev This takes priority no matter what access (full/zone/function) the role has.\n    function changeZoneBlacklist(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external;\n}\n"
        },
        "lib/trustless-management/src/TrustlessManagement.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC165} from \"../lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\";\nimport {ENSReverseClaimable} from \"../lib/ens-reverse-claimable/src/ENSReverseClaimable.sol\";\n\nimport {IPermissionChecker} from \"./IPermissionChecker.sol\";\nimport {ITrustlessManagement, IDAOManager, IDAO, IDAOExtensionWithAdmin} from \"./ITrustlessManagement.sol\";\n\naddress constant NO_PERMISSION_CHECKER = address(type(uint160).max);\nbytes32 constant EXECUTION_ID = keccak256(\"TRUSTLESS_MANAGEMENT\");\n\nabstract contract TrustlessManagement is ERC165, ENSReverseClaimable, ITrustlessManagement {\n    mapping(IDAO dao => DAOInfo info) private daoInfo;\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(ITrustlessManagement).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function hasRole(address _account, uint256 _roleId) public view virtual returns (bool);\n\n    /// @inheritdoc ITrustlessManagement\n    function isAllowed(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions) public view returns (bool) {\n        PermissionInfo storage permissions = daoInfo[_dao].permissions[_role];\n\n        for (uint256 i; i < _actions.length;) {\n            uint256 functionId = _functionId(_actions[i].to, bytes4(_actions[i].data));\n            if (\n                _checkPermission(permissions.functionBlacklist[functionId], _role, _actions[i])\n                    || _checkPermission(permissions.zoneBlacklist[_actions[i].to], _role, _actions[i])\n            ) {\n                // Blacklisted\n                return false;\n            }\n\n            if (\n                !_checkPermission(permissions.fullAccess, _role, _actions[i])\n                    && !_checkPermission(permissions.zoneAccess[_actions[i].to], _role, _actions[i])\n                    && !_checkPermission(permissions.functionAccess[functionId], _role, _actions[i])\n            ) {\n                // Permission not granted\n                return false;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // No action rejected => allowed\n        return true;\n    }\n\n    /// @inheritdoc IDAOManager\n    function asDAO(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions, uint256 _failureMap)\n        external\n        returns (bytes[] memory returnValues, uint256 failureMap)\n    {\n        if (!hasRole(msg.sender, _role)) {\n            revert SenderDoesNotHaveRole();\n        }\n        if (!isAllowed(_dao, _role, _actions)) {\n            revert AccessDenied();\n        }\n\n        (returnValues, failureMap) = _dao.execute(EXECUTION_ID, _actions, _failureMap);\n        emit Execution(_dao, _role, msg.sender, _actions, returnValues, failureMap);\n    }\n\n    /// @inheritdoc IDAOExtensionWithAdmin\n    function setAdmin(IDAO _dao, address _admin) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.admin = _admin;\n        emit AdminSet(_dao, _admin);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeFullAccess(IDAO _dao, uint256 _role, address _permissionChecker) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].fullAccess = _permissionChecker;\n        emit FullAccessChanged(_dao, _role, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeZoneAccess(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].zoneAccess[_zone] = _permissionChecker;\n        emit ZoneAccessChanged(_dao, _role, _zone, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeZoneBlacklist(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].zoneBlacklist[_zone] = _permissionChecker;\n        emit ZoneBlacklistChanged(_dao, _role, _zone, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeFunctionAccess(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].functionAccess[_functionId(_zone, _functionSelector)] = _permissionChecker;\n        emit FunctionAccessChanged(_dao, _role, _zone, _functionSelector, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeFunctionBlacklist(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].functionBlacklist[_functionId(_zone, _functionSelector)] = _permissionChecker;\n        emit FunctionBlacklistChanged(_dao, _role, _zone, _functionSelector, _permissionChecker);\n    }\n\n    function _checkPermission(address _permissionChecker, uint256 _role, IDAO.Action calldata _action)\n        internal\n        view\n        returns (bool)\n    {\n        if (_permissionChecker == address(0)) {\n            // Permission not granted\n            return false;\n        }\n        if (_permissionChecker == NO_PERMISSION_CHECKER) {\n            // Permission always granted\n            return true;\n        }\n\n        // Additional check\n        return IPermissionChecker(_permissionChecker).checkPermission(_role, _action);\n    }\n\n    // address + function selector\n    function _functionId(address _zone, bytes4 _functionSelector) internal pure returns (uint256) {\n        return (uint160(bytes20(_zone)) << 32) + uint32(_functionSelector);\n    }\n\n    function _ensureSenderIsAdmin(IDAO _dao, address _admin) internal view {\n        if (_admin == address(0)) {\n            // Admin not set means DAO is the admin\n            if (msg.sender != address(_dao)) {\n                revert SenderIsNotAdmin();\n            }\n        } else {\n            // Specific admin will only be allowed. DAO is not allowed to change permissions. (for example: if it is a SubDAO)\n            if (msg.sender != _admin) {\n                revert SenderIsNotAdmin();\n            }\n        }\n    }\n}\n"
        },
        "src/SmartAccountDepartmentInstaller.sol": {
          "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    SmartAccountTrustlessExecutionLib,\n    ISmartAccountTrustlessExecution\n} from \"../lib/smart-account/src/modules/trustless-execution/SmartAccountTrustlessExecutionLib.sol\";\n\nimport {\n    ITrustlessManagement, IDAO, NO_PERMISSION_CHECKER\n} from \"../lib/trustless-management/src/TrustlessManagement.sol\";\nimport {IOptimisticActions, IDAO as IOptimsticActionDAO} from \"../lib/trustless-actions/src/IOptimisticActions.sol\";\n\ncontract SmartAccountDepartmentInstaller {\n    event DepartmentInstalled(address indexed department, bytes32 indexed tag);\n\n    /// @notice The smart account module to add execute, which is needed to use trustless management.\n    ISmartAccountTrustlessExecution public immutable smartAccountTrustlessExecution;\n\n    /// @notice Address trustless management (for creating optimstic actions).\n    ITrustlessManagement public immutable tagTrustlessManagement;\n\n    /// @notice Address trustless management (for executing optimstic actions).\n    ITrustlessManagement public immutable addressTrustlessManagement;\n\n    /// @notice The optimstic actions implementation.\n    IOptimisticActions public immutable optimisticActions;\n\n    /// @notice The address of OpenR&D that will be optimsticly interactable for departments by default.\n    address public immutable openRD;\n\n    constructor(\n        ISmartAccountTrustlessExecution _smartAccountTrustlessExecution,\n        ITrustlessManagement _tagTrustlessManagement,\n        ITrustlessManagement _addressTrustlessManagement,\n        IOptimisticActions _optimisticActions,\n        address _openRD\n    ) {\n        smartAccountTrustlessExecution = _smartAccountTrustlessExecution;\n        tagTrustlessManagement = _tagTrustlessManagement;\n        addressTrustlessManagement = _addressTrustlessManagement;\n        optimisticActions = _optimisticActions;\n        openRD = _openRD;\n    }\n\n    function install(bytes32 _tag) external {\n        // Install smart account module\n        SmartAccountTrustlessExecutionLib.fullInstall(address(smartAccountTrustlessExecution));\n\n        // Enable trustless management (give execute permission).\n        SmartAccountTrustlessExecutionLib.setExecutePermission(address(tagTrustlessManagement), true);\n        SmartAccountTrustlessExecutionLib.setExecutePermission(address(addressTrustlessManagement), true);\n\n        // Set trustless management permissions and optmistic actions delay.\n        tagTrustlessManagement.changeFunctionAccess(\n            IDAO(address(this)),\n            uint256(_tag),\n            address(optimisticActions),\n            optimisticActions.createAction.selector,\n            NO_PERMISSION_CHECKER\n        );\n        tagTrustlessManagement.changeFunctionAccess(\n            IDAO(address(this)),\n            uint256(_tag),\n            address(optimisticActions),\n            optimisticActions.rejectAction.selector,\n            NO_PERMISSION_CHECKER\n        );\n        optimisticActions.setExecuteDelay(IOptimsticActionDAO(address(this)), 7 days);\n        addressTrustlessManagement.changeZoneAccess(\n            IDAO(address(this)), uint160(address(optimisticActions)), openRD, NO_PERMISSION_CHECKER\n        );\n\n        emit DepartmentInstalled(address(this), _tag);\n    }\n}\n"
        }
      },
      "settings": {
        "remappings": [
          "@aragon/osx-commons-contracts/=lib/osx-commons/contracts/",
          "@ensdomains/ens-contracts/=lib/ens-contracts/",
          "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
          "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
          "aragon-tag-voting/=lib/aragon-tag-voting/src/",
          "ds-test/=lib/openzeppelin-contracts-v5/lib/forge-std/lib/ds-test/src/",
          "ens-contracts/=lib/ens-contracts/contracts/",
          "ens-reverse-claimable/=lib/openmesh-admin/lib/ens-reverse-claimable/src/",
          "erc4626-tests/=lib/openzeppelin-contracts-v5/lib/erc4626-tests/",
          "forge-std/=lib/forge-std/src/",
          "openmesh-admin/=lib/openmesh-admin/src/",
          "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
          "openzeppelin-contracts-v5/=lib/openzeppelin-contracts-v5/",
          "openzeppelin-contracts/=lib/openzeppelin-contracts/",
          "openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/",
          "osx-commons/=lib/osx-commons/",
          "osx/=lib/osx/",
          "smart-account/=lib/smart-account/src/",
          "tag-manager/=lib/tag-manager/src/",
          "trustless-actions/=lib/trustless-actions/src/",
          "trustless-management/=lib/trustless-management/src/",
          "verified-contributor/=lib/verified-contributor/src/"
        ],
        "optimizer": { "enabled": true, "runs": 200 },
        "evmVersion": "shanghai",
        "viaIR": true
      },
      "metadata": { "useLiteralContent": true }
    },
    "license": "MIT"
  },
  "source": "/home/plopmenz/openmesh-smart-contracts/lib/openmesh-department",
  "submitted": {
    "transactionHash": "0x04ba7fd23887afe12a38b7eca5d12c79c03594428efac149ca497e442e170499",
    "date": "2024-04-01T20:43:14.338Z"
  }
}
