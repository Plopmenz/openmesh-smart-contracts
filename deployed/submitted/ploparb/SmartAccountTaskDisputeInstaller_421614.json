{"type":"deployment","id":"SmartAccountTaskDisputeInstaller_421614","batch":"ploparb","batchIndex":21,"deploymentAddress":"0x0509492F623D2700e85b0187572eC9Fd8FE5716d","constructorArgs":["0x9478eaab9F531533487c220C451820c3c7901e6b","0xDE87dC6C365dD751e650AAe2f2f6A7a599aed58E","0x366D84094b553B2A7d64C3B57cB649323a394C04","0xb082d1323068ca6c123EB7eB94b104E0f83127DE","0x4436DF92364aBc450AfeC494ED492C2C9D713bc5"],"to":"0x4e59b44847b379578588920ca78fbf26c0b4956c","value":"0","data":"0x00000000000000000000000000000000000000000000000000706c6f706172626101203461012b57601f6109f338819003918201601f19168301916001600160401b0383118484101761012f5780849260a09460405283398101031261012b5780516001600160a01b039190828116810361012b576020820151838116810361012b57604083015191848316830361012b57606084015193858516850361012b5760800151948516850361012b5760805260a05260c05260e0526101009081526040516108af9182610144833960805182818161014c015261035d015260a051828181610243015281816102bf015281816104aa015281816105720152610765015260c05182818161031a0152818161054f0152610742015260e05182818160db015281816105b0015281816106c101526107a6015251818181609401528181610632015261081e0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040908082526004361015610014575f80fd5b5f3560e01c9081632dcd8323146103a857508063316cfac71461038c57806335ece0721461034957806344efaaeb14610306578063473d2fdf146102ee5780637ae0d914146102ab5780638652d2dd1461010a5780638ae1740c146100c75763c305a6d914610081575f80fd5b346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5f80fd5b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100c357602090816003193601126100c3577f34051a60a9aba6f1aab675ea08454fec104dde53056b328a8578b589e2a3a667916001808060a01b0391827f000000000000000000000000000000000000000000000000000000000000000016927f0e1b22cdaccd652db85cbcd4ee8f705beabfaa30664122ccc544137ef20749bb856331c6fcc960e21b95865f527f56a2f102f06100e6e9193cce9cca60c6a83719df4146213240bdd4963e5931ba8552815f20816bffffffffffffffffffffffff60a01b82541617905581519087825285820152a1835f527f1164ff701c332a936c6fdd0cee9b71313a2f7a4aebd6e4eb4e5f25a54a3bd7d78252845f209360ff199484868254161790557f0ec03a921b5deb73a9948473b4744dde91adeb598eacc1fca09623171feafb3e838751868152a27f00000000000000000000000000000000000000000000000000000000000000001692835f527f6773380c68a4f1b5fc0767331b3f78df01c93053a8577bbdc258bc2fa4d79a4a825282855f20918254161790558351928352820152a16102a960043561053c565b005b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346100c3575f3660031901126100c3576102a9610737565b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346100c35760203660031901126100c3576102a960043561053c565b82346100c3575f3660031901126100c3576331c6fcc960e21b5f8181527f56a2f102f06100e6e9193cce9cca60c6a83719df4146213240bdd4963e5931ba602090815283822080546001600160a01b03191690558285528085018290527f34051a60a9aba6f1aab675ea08454fec104dde53056b328a8578b589e2a3a667947f0e1b22cdaccd652db85cbcd4ee8f705beabfaa30664122ccc544137ef20749bb908590a18282527f1164ff701c332a936c6fdd0cee9b71313a2f7a4aebd6e4eb4e5f25a54a3bd7d781528382209260ff19938481541690557f0ec03a921b5deb73a9948473b4744dde91adeb598eacc1fca09623171feafb3e828651858152a27f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168083527f6773380c68a4f1b5fc0767331b3f78df01c93053a8577bbdc258bc2fa4d79a4a825284832080549094169093558351928352820152a16102a9610737565b67ffffffffffffffff811161052857604052565b634e487b7160e01b5f52604160045260245ffd5b5f90806106bf575b506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081167f00000000000000000000000000000000000000000000000000000000000000008216803b156106bb5760405163d45cfee960e01b8082523060048301527f00000000000000000000000000000000000000000000000000000000000000008516602483015260448201849052634e8cbc7160e11b6064830152608482018590529190858160a48183865af180156106b05790869161069c575b5050803b15610698578492918360a492604051968795869485523060048601526024850152807f000000000000000000000000000000000000000000000000000000000000000016604485015263285e546f60e11b606485015260848401525af1801561068d57610679575050565b6106838291610514565b61068a5750565b80fd5b6040513d84823e3d90fd5b8480fd5b6106a590610514565b61069857845f61060a565b6040513d88823e3d90fd5b8380fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690813b156100c3575f91602483926040519485938492630478b41160e31b845260048401525af1801561072c5715610544576107259150610514565b5f80610544565b6040513d5f823e3d90fd5b5f6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081167f00000000000000000000000000000000000000000000000000000000000000008216803b156100c3576040519063d45cfee960e01b91828152306004820152847f0000000000000000000000000000000000000000000000000000000000000000166024820152836044820152634e8cbc7160e11b60648201525f60848201525f8160a48183865af1801561072c57610866575b50803b15610698578492918360a4926040519687958694855230600486015260248501527f000000000000000000000000000000000000000000000000000000000000000016604484015263285e546f60e11b60648401525f60848401525af1801561068d57610679575050565b610871919550610514565b5f935f6107f856fea26469706673582212202bf4cbd9a39650525327e16bb6e7f06ee160e5bc5cd7a99581d2c67007ad476d64736f6c634300081700330000000000000000000000009478eaab9f531533487c220c451820c3c7901e6b000000000000000000000000de87dc6c365dd751e650aae2f2f6a7a599aed58e000000000000000000000000366d84094b553b2a7d64c3b57cb649323a394c04000000000000000000000000b082d1323068ca6c123eb7eb94b104e0f83127de0000000000000000000000004436df92364abc450afec494ed492c2c9d713bc5","gas":"543040","from":"0xaF7E68bCb2Fc7295492A00177f14F59B92814e70","transactionSettings":{"chainId":421614,"nonce":"11","baseFee":"1000000000","priorityFee":"100000000"},"salt":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000ploparb","artifact":{"abi":[{"type":"constructor","inputs":[{"name":"_smartAccountTrustlessExecution","type":"address","internalType":"contract ISmartAccountTrustlessExecution"},{"name":"_addressTrustlessManagement","type":"address","internalType":"contract ITrustlessManagement"},{"name":"_trustlessActions","type":"address","internalType":"contract ITrustlessActions"},{"name":"_taskDisputes","type":"address","internalType":"contract IPaidAction"},{"name":"_tasks","type":"address","internalType":"contract ITasks"}],"stateMutability":"nonpayable"},{"type":"function","name":"addressTrustlessManagement","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract ITrustlessManagement"}],"stateMutability":"view"},{"type":"function","name":"fullInstall","inputs":[{"name":"_cost","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"fullUninstall","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"paidAction","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract IPaidAction"}],"stateMutability":"view"},{"type":"function","name":"permissionsInstall","inputs":[{"name":"_cost","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"permissionsUninstall","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"smartAccountTrustlessExecution","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract ISmartAccountTrustlessExecution"}],"stateMutability":"view"},{"type":"function","name":"tasks","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract ITasks"}],"stateMutability":"view"},{"type":"function","name":"trustlessActions","inputs":[],"outputs":[{"name":"","type":"address","internalType":"contract ITrustlessActions"}],"stateMutability":"view"},{"type":"event","name":"ExecutePermissionSet","inputs":[{"name":"account","type":"address","indexed":false,"internalType":"address"},{"name":"allowed","type":"bool","indexed":false,"internalType":"bool"}],"anonymous":false},{"type":"event","name":"InterfaceSupportedChanged","inputs":[{"name":"interfaceId","type":"bytes4","indexed":true,"internalType":"bytes4"},{"name":"supported","type":"bool","indexed":false,"internalType":"bool"}],"anonymous":false},{"type":"event","name":"ModuleSet","inputs":[{"name":"functionSelector","type":"bytes4","indexed":false,"internalType":"bytes4"},{"name":"module","type":"address","indexed":false,"internalType":"address"}],"anonymous":false}],"bytecode":"0x6101203461012b57601f6109f338819003918201601f19168301916001600160401b0383118484101761012f5780849260a09460405283398101031261012b5780516001600160a01b039190828116810361012b576020820151838116810361012b57604083015191848316830361012b57606084015193858516850361012b5760800151948516850361012b5760805260a05260c05260e0526101009081526040516108af9182610144833960805182818161014c015261035d015260a051828181610243015281816102bf015281816104aa015281816105720152610765015260c05182818161031a0152818161054f0152610742015260e05182818160db015281816105b0015281816106c101526107a6015251818181609401528181610632015261081e0152f35b5f80fd5b634e487b7160e01b5f52604160045260245ffdfe60806040908082526004361015610014575f80fd5b5f3560e01c9081632dcd8323146103a857508063316cfac71461038c57806335ece0721461034957806344efaaeb14610306578063473d2fdf146102ee5780637ae0d914146102ab5780638652d2dd1461010a5780638ae1740c146100c75763c305a6d914610081575f80fd5b346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b5f80fd5b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100c357602090816003193601126100c3577f34051a60a9aba6f1aab675ea08454fec104dde53056b328a8578b589e2a3a667916001808060a01b0391827f000000000000000000000000000000000000000000000000000000000000000016927f0e1b22cdaccd652db85cbcd4ee8f705beabfaa30664122ccc544137ef20749bb856331c6fcc960e21b95865f527f56a2f102f06100e6e9193cce9cca60c6a83719df4146213240bdd4963e5931ba8552815f20816bffffffffffffffffffffffff60a01b82541617905581519087825285820152a1835f527f1164ff701c332a936c6fdd0cee9b71313a2f7a4aebd6e4eb4e5f25a54a3bd7d78252845f209360ff199484868254161790557f0ec03a921b5deb73a9948473b4744dde91adeb598eacc1fca09623171feafb3e838751868152a27f00000000000000000000000000000000000000000000000000000000000000001692835f527f6773380c68a4f1b5fc0767331b3f78df01c93053a8577bbdc258bc2fa4d79a4a825282855f20918254161790558351928352820152a16102a960043561053c565b005b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346100c3575f3660031901126100c3576102a9610737565b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b50346100c3575f3660031901126100c357517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b346100c35760203660031901126100c3576102a960043561053c565b82346100c3575f3660031901126100c3576331c6fcc960e21b5f8181527f56a2f102f06100e6e9193cce9cca60c6a83719df4146213240bdd4963e5931ba602090815283822080546001600160a01b03191690558285528085018290527f34051a60a9aba6f1aab675ea08454fec104dde53056b328a8578b589e2a3a667947f0e1b22cdaccd652db85cbcd4ee8f705beabfaa30664122ccc544137ef20749bb908590a18282527f1164ff701c332a936c6fdd0cee9b71313a2f7a4aebd6e4eb4e5f25a54a3bd7d781528382209260ff19938481541690557f0ec03a921b5deb73a9948473b4744dde91adeb598eacc1fca09623171feafb3e828651858152a27f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168083527f6773380c68a4f1b5fc0767331b3f78df01c93053a8577bbdc258bc2fa4d79a4a825284832080549094169093558351928352820152a16102a9610737565b67ffffffffffffffff811161052857604052565b634e487b7160e01b5f52604160045260245ffd5b5f90806106bf575b506001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081167f00000000000000000000000000000000000000000000000000000000000000008216803b156106bb5760405163d45cfee960e01b8082523060048301527f00000000000000000000000000000000000000000000000000000000000000008516602483015260448201849052634e8cbc7160e11b6064830152608482018590529190858160a48183865af180156106b05790869161069c575b5050803b15610698578492918360a492604051968795869485523060048601526024850152807f000000000000000000000000000000000000000000000000000000000000000016604485015263285e546f60e11b606485015260848401525af1801561068d57610679575050565b6106838291610514565b61068a5750565b80fd5b6040513d84823e3d90fd5b8480fd5b6106a590610514565b61069857845f61060a565b6040513d88823e3d90fd5b8380fd5b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690813b156100c3575f91602483926040519485938492630478b41160e31b845260048401525af1801561072c5715610544576107259150610514565b5f80610544565b6040513d5f823e3d90fd5b5f6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081167f00000000000000000000000000000000000000000000000000000000000000008216803b156100c3576040519063d45cfee960e01b91828152306004820152847f0000000000000000000000000000000000000000000000000000000000000000166024820152836044820152634e8cbc7160e11b60648201525f60848201525f8160a48183865af1801561072c57610866575b50803b15610698578492918360a4926040519687958694855230600486015260248501527f000000000000000000000000000000000000000000000000000000000000000016604484015263285e546f60e11b60648401525f60848401525af1801561068d57610679575050565b610871919550610514565b5f935f6107f856fea26469706673582212202bf4cbd9a39650525327e16bb6e7f06ee160e5bc5cd7a99581d2c67007ad476d64736f6c63430008170033","compiler":{"version":"v0.8.23+commit.f704f362"},"contractName":"src/TaskDisputes/SmartAccountTaskDisputeInstaller.sol:SmartAccountTaskDisputeInstaller","jsonDescription":{"language":"Solidity","sources":{"lib/openrd-foundry/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"},"lib/openrd-foundry/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"lib/openrd-foundry/lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"},"lib/openrd-foundry/lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"},"lib/openrd-foundry/src/Escrow.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {IERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"../lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract Escrow {\r\n    using SafeERC20 for IERC20;\r\n\r\n    error AlreadyInitialized();\r\n    error NotOwner();\r\n    error NativeTransferFailed();\r\n\r\n    address internal owner;\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    /// @notice Initializes the Escrow with the sender of the transaction as owner.\r\n    /// @dev This should be called in the same transaction as deploying the escrow, to prevent front running.\r\n    function __Escrow_init() public payable {\r\n        if (owner != address(0)) {\r\n            revert AlreadyInitialized();\r\n        }\r\n\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of ERC20 token to a given address. Can only be called by the owner.\r\n    /// @param token The ERC20 contract address.\r\n    /// @param to The address to recieve the tokens.\r\n    /// @param amount The amount of ERC20 token to receive.\r\n    /// @dev Wont do anything if amount is 0.\r\n    function transfer(IERC20 token, address to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        if (amount != 0) {\r\n            token.safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers a certain amount of native currency to a given address. Can only be called by the owner.\r\n    /// @param to The address to recieve the currency.\r\n    /// @param amount The amount of native currency to receive.\r\n    /// @dev Wont do anything if amount is 0.\r\n    function transferNative(address payable to, uint256 amount) external {\r\n        if (msg.sender != owner) {\r\n            revert NotOwner();\r\n        }\r\n\r\n        if (amount != 0) {\r\n            // Use call instead of transfer for correct gas estimation to smart contracts\r\n            (bool succes,) = to.call{value: amount}(\"\");\r\n            if (!succes) {\r\n                revert NativeTransferFailed();\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"lib/openrd-foundry/src/ITasks.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport {Escrow, IERC20} from \"./Escrow.sol\";\r\n\r\ninterface ITasks {\r\n    error TaskDoesNotExist();\r\n    error TaskNotOpen();\r\n    error TaskNotTaken();\r\n    error TaskNotClosed();\r\n    error TaskClosed();\r\n\r\n    error NotManager();\r\n    error NotExecutor();\r\n    error NotDisputeManager();\r\n\r\n    error RewardAboveBudget();\r\n    error RewardDoesntEndWithNextToken();\r\n    error NotEnoughNativeCurrencyAttached();\r\n    error ApplicationDoesNotExist();\r\n    error NotYourApplication();\r\n    error ApplicationNotAccepted();\r\n    error SubmissionDoesNotExist();\r\n    error SubmissionAlreadyJudged();\r\n    error JudgementNone();\r\n\r\n    error RequestDoesNotExist();\r\n    error RequestAlreadyAccepted();\r\n    error RequestNotAccepted();\r\n    error RequestAlreadyExecuted();\r\n\r\n    error Overflow();\r\n    error ManualBudgetIncreaseNeeded();\r\n    error PartialRewardAboveFullReward();\r\n    error NativeTransferFailed();\r\n    error ERC1167FailedCreateClone();\r\n\r\n    // The budget here repesents the call of the funder to the escrow, the actual value in the escrow (actual budget) might differ in case of transfer fees / rewards.\r\n    event TaskCreated(\r\n        uint256 indexed taskId,\r\n        string metadata,\r\n        uint64 deadline,\r\n        address manager,\r\n        address disputeManager,\r\n        address creator,\r\n        uint96 nativeBudget,\r\n        ERC20Transfer[] budget,\r\n        Escrow escrow\r\n    );\r\n    event ApplicationCreated(\r\n        uint256 indexed taskId,\r\n        uint32 indexed applicationId,\r\n        string metadata,\r\n        address applicant,\r\n        NativeReward[] nativeReward,\r\n        Reward[] reward\r\n    );\r\n    event ApplicationAccepted(uint256 indexed taskId, uint32 indexed applicationId);\r\n    event TaskTaken(uint256 indexed taskId, uint32 indexed applicationId);\r\n    event SubmissionCreated(uint256 indexed taskId, uint8 indexed submissionId, string metadata);\r\n    event SubmissionReviewed(\r\n        uint256 indexed taskId, uint8 indexed submissionId, SubmissionJudgement judgement, string feedback\r\n    );\r\n    event TaskCompleted(uint256 indexed taskId, TaskCompletionSource source);\r\n\r\n    event CancelTaskRequested(uint256 indexed taskId, uint8 indexed requestId, string metadata);\r\n    event TaskCancelled(uint256 indexed taskId, string metadata);\r\n    event RequestAccepted(uint256 indexed taskId, RequestType indexed requestType, uint8 indexed requestId);\r\n    event RequestExecuted(uint256 indexed taskId, RequestType indexed requestType, uint8 indexed requestId, address by);\r\n\r\n    event DeadlineChanged(uint256 indexed taskId, uint64 newDeadline);\r\n    event BudgetChanged(uint256 indexed taskId); // Quite expensive to transfer budget into a datastructure to emit\r\n    event RewardIncreased(\r\n        uint256 indexed taskId, uint32 indexed applicationId, uint96[] nativeIncrease, uint88[] increase\r\n    );\r\n    event MetadataChanged(uint256 indexed taskId, string newMetadata);\r\n    event ManagerChanged(uint256 indexed taskId, address newManager);\r\n    event PartialPayment(uint256 indexed taskId, uint96[] partialNativeReward, uint88[] partialReward);\r\n\r\n    /// @notice A container for ERC20 transfer information.\r\n    /// @param tokenContract ERC20 token to transfer.\r\n    /// @param amount How much of this token should be transfered. uint96 to keep struct packed into a single uint256.\r\n    struct ERC20Transfer {\r\n        IERC20 tokenContract;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a native reward payout.\r\n    /// @param to Whom the native reward should be transfered to.\r\n    /// @param amount How much native reward should be transfered. uint96 to keep struct packed into a single uint256.\r\n    struct NativeReward {\r\n        address to;\r\n        uint96 amount;\r\n    }\r\n\r\n    /// @notice A container for a reward payout.\r\n    /// @param nextToken If this reward is payed out in the next ERC20 token.\r\n    /// @dev IERC20 (address) is a lot of storage, rather just keep those only in budget.\r\n    /// @notice nextToken should always be true for the last entry\r\n    /// @param to Whom this token should be transfered to.\r\n    /// @param amount How much of this token should be transfered. uint88 to keep struct packed into a single uint256.\r\n    struct Reward {\r\n        bool nextToken;\r\n        address to;\r\n        uint88 amount;\r\n    }\r\n\r\n    /// @notice A container for a task application.\r\n    /// @param metadata Metadata of the application. (IPFS hash)\r\n    /// @param applicant Who has submitted this application.\r\n    /// @param accepted If the application has been accepted by the manager.\r\n    /// @param nativeReward How much native currency the applicant wants for completion.\r\n    /// @param reward How much rewards the applicant wants for completion.\r\n    struct Application {\r\n        string metadata;\r\n        // Storage block seperator\r\n        address applicant;\r\n        bool accepted;\r\n        uint8 nativeRewardCount;\r\n        uint8 rewardCount;\r\n        // Storage block seperator\r\n        mapping(uint8 => NativeReward) nativeReward;\r\n        mapping(uint8 => Reward) reward;\r\n    }\r\n\r\n    struct OffChainApplication {\r\n        string metadata;\r\n        address applicant;\r\n        bool accepted;\r\n        NativeReward[] nativeReward;\r\n        Reward[] reward;\r\n    }\r\n\r\n    /// @notice For approving people on task creation (they are not required to make an application).\r\n    struct PreapprovedApplication {\r\n        address applicant;\r\n        NativeReward[] nativeReward;\r\n        Reward[] reward;\r\n    }\r\n\r\n    enum SubmissionJudgement {\r\n        None,\r\n        Accepted,\r\n        Rejected\r\n    }\r\n\r\n    /// @notice A container for a task submission.\r\n    /// @param metadata Metadata of the submission. (IPFS hash)\r\n    /// @param judgement Judgement cast on the submission.\r\n    /// @param feedback A response from the manager. (IPFS hash)\r\n    struct Submission {\r\n        string metadata;\r\n        string feedback;\r\n        SubmissionJudgement judgement;\r\n    }\r\n\r\n    // This is for future expansion of the request system\r\n    enum RequestType {CancelTask}\r\n\r\n    /// @notice A container for shared request information.\r\n    /// @param accepted If the request was accepted.\r\n    /// @param executed If the request was executed.\r\n    struct Request {\r\n        bool accepted;\r\n        bool executed;\r\n    }\r\n\r\n    /// @notice A container for a request to cancel the task.\r\n    /// @param request Request information.\r\n    /// @param metadata Metadata of the request. (IPFS hash, Why the task should be cancelled)\r\n    struct CancelTaskRequest {\r\n        Request request;\r\n        string metadata;\r\n    }\r\n\r\n    enum TaskState {\r\n        Open,\r\n        Taken,\r\n        Closed\r\n    }\r\n\r\n    /// @notice A container for task-related information.\r\n    /// @param metadata Metadata of the task. (IPFS hash)\r\n    /// @param deadline Block timestamp at which the task expires if not completed.\r\n    /// @param escrow The address of the escrow which holds the budget funds.\r\n    /// @param budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param nativeBudget Maximum native currency reward that can be earned by completing the task.\r\n    /// @param creator Who has created the task.\r\n    /// @param disputeManager Who has the permission to complete the task without the managers approval.\r\n    /// @param manager Who has the permission to manage the task.\r\n    /// @param state Current state the task is in.\r\n    /// @param applications Applications to take the job.\r\n    /// @param executorApplication Index of the application that will execture the task.\r\n    /// @param submissions Submission made to finish the task.\r\n    struct Task {\r\n        string metadata;\r\n        // Storage block seperator\r\n        uint64 deadline;\r\n        Escrow escrow;\r\n        // Storage block seperator\r\n        uint96 nativeBudget;\r\n        address creator;\r\n        // Storage block seperator\r\n        address disputeManager;\r\n        // Storage block seperator\r\n        address manager;\r\n        TaskState state;\r\n        uint32 executorApplication;\r\n        uint8 budgetCount;\r\n        uint32 applicationCount;\r\n        uint8 submissionCount;\r\n        uint8 cancelTaskRequestCount;\r\n        // Storage block seperator\r\n        mapping(uint8 => ERC20Transfer) budget;\r\n        mapping(uint32 => Application) applications;\r\n        mapping(uint8 => Submission) submissions;\r\n        mapping(uint8 => CancelTaskRequest) cancelTaskRequests;\r\n    }\r\n\r\n    struct OffChainTask {\r\n        string metadata;\r\n        uint64 deadline;\r\n        uint32 executorApplication;\r\n        address manager;\r\n        address disputeManager;\r\n        address creator;\r\n        TaskState state;\r\n        Escrow escrow;\r\n        uint96 nativeBudget;\r\n        ERC20Transfer[] budget;\r\n        OffChainApplication[] applications;\r\n        Submission[] submissions;\r\n        CancelTaskRequest[] cancelTaskRequests;\r\n    }\r\n\r\n    enum TaskCompletionSource {\r\n        SubmissionAccepted,\r\n        Dispute\r\n    }\r\n\r\n    /// @notice Retrieves the current amount of created tasks.\r\n    function taskCount() external view returns (uint256);\r\n\r\n    /// @notice Retrieves all task information by id.\r\n    /// @param _taskId Id of the task.\r\n    function getTask(uint256 _taskId) external view returns (OffChainTask memory);\r\n\r\n    /// @notice Retrieves multiple tasks in a single call.\r\n    /// @param _taskIds Ids of the tasks.\r\n    function getTasks(uint256[] calldata _taskIds) external view returns (OffChainTask[] memory);\r\n\r\n    /// @notice Create a new task.\r\n    /// @param _metadata Metadata of the task. (IPFS hash)\r\n    /// @param _deadline Block timestamp at which the task expires if not completed.\r\n    /// @param _manager Who will manage the task (become the manager).\r\n    /// @param _disputeManager Who will manage the disputes (handle situations where the manager and executor are in disagreement).\r\n    /// @param _budget Maximum ERC20 rewards that can be earned by completing the task.\r\n    /// @param _preapprove List of addresses (with reward) that are able to take the task without creating an application themselves.\r\n    /// @return taskId Id of the newly created task.\r\n    function createTask(\r\n        string calldata _metadata,\r\n        uint64 _deadline,\r\n        address _manager,\r\n        address _disputeManager,\r\n        ERC20Transfer[] calldata _budget,\r\n        PreapprovedApplication[] calldata _preapprove\r\n    ) external payable returns (uint256 taskId);\r\n\r\n    /// @notice Apply to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of your application.\r\n    /// @param _nativeReward Wanted native currency for completing the task.\r\n    /// @param _reward Wanted rewards for completing the task.\r\n    /// @return applicationId Id of the newly created application.\r\n    function applyForTask(\r\n        uint256 _taskId,\r\n        string calldata _metadata,\r\n        NativeReward[] calldata _nativeReward,\r\n        Reward[] calldata _reward\r\n    ) external returns (uint32 applicationId);\r\n\r\n    /// @notice Accept application to allow them to take the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationIds Indexes of the applications to accept.\r\n    /// @dev Will revert if applicant reward is higher than the budget. increaseBudget should be called beforehand.\r\n    function acceptApplications(uint256 _taskId, uint32[] calldata _applicationIds) external;\r\n\r\n    /// @notice Take the task after your application has been accepted.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Index of application you made that has been accepted.\r\n    function takeTask(uint256 _taskId, uint32 _applicationId) external;\r\n\r\n    /// @notice Create a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Metadata of the submission. (IPFS hash)\r\n    /// @return submissionId Id of the newly created submission.\r\n    function createSubmission(uint256 _taskId, string calldata _metadata) external returns (uint8 submissionId);\r\n\r\n    /// @notice Review a submission.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _submissionId Index of the submission that is reviewed.\r\n    /// @param _judgement Outcome of the review.\r\n    /// @param _feedback Reasoning of the reviewer. (IPFS hash)\r\n    function reviewSubmission(\r\n        uint256 _taskId,\r\n        uint8 _submissionId,\r\n        SubmissionJudgement _judgement,\r\n        string calldata _feedback\r\n    ) external;\r\n\r\n    /// @notice Cancels a task. This can be used to close a task and receive back the budget.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _metadata Why the task was cancelled. (IPFS hash)\r\n    /// @return cancelTaskRequestId Id of the newly created request for task cancellation.\r\n    function cancelTask(uint256 _taskId, string calldata _metadata) external returns (uint8 cancelTaskRequestId);\r\n\r\n    /// @notice Accepts a request, executing the proposed action.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    /// @param _execute If the request should also be executed in this transaction.\r\n    function acceptRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId, bool _execute) external;\r\n\r\n    /// @notice Exectued an accepted request, allows anyone to pay for the gas costs of the execution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _requestType What kind of request it is.\r\n    /// @param _requestId Id of the request.\r\n    function executeRequest(uint256 _taskId, RequestType _requestType, uint8 _requestId) external;\r\n\r\n    /// @notice Extend the deadline of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _extension How much to extend the deadline by.\r\n    function extendDeadline(uint256 _taskId, uint64 _extension) external;\r\n\r\n    /// @notice Increase the budget of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    /// @dev Any attached native reward will also be used to increase the budget.\r\n    function increaseBudget(uint256 _taskId, uint96[] calldata _increase) external payable;\r\n\r\n    /// @notice Increase the reward of an application of the task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _applicationId Id of the application.\r\n    /// @param _nativeIncrease How much to increase each native amount by.\r\n    /// @param _increase How much to increase each tokens amount by.\r\n    function increaseReward(\r\n        uint256 _taskId,\r\n        uint32 _applicationId,\r\n        uint96[] calldata _nativeIncrease,\r\n        uint88[] calldata _increase\r\n    ) external;\r\n\r\n    /// @notice Edit the metadata of a task.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newMetadata New metadata of the task.\r\n    /// @dev This metadata update might change the task completely. Show a warning to people who applied before the change.\r\n    function editMetadata(uint256 _taskId, string calldata _newMetadata) external;\r\n\r\n    /// @notice Transfers the manager role to a different address.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _newManager What address should become the manager.\r\n    function transferManagement(uint256 _taskId, address _newManager) external;\r\n\r\n    /// @notice Completes the task through dispute resolution.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    function completeByDispute(\r\n        uint256 _taskId,\r\n        uint96[] calldata _partialNativeReward,\r\n        uint88[] calldata _partialReward\r\n    ) external;\r\n\r\n    /// @notice Releases a part of the reward to the executor without marking the task as complete.\r\n    /// @param _taskId Id of the task.\r\n    /// @param _partialNativeReward How much of each native reward should be paid out.\r\n    /// @param _partialReward How much of each ERC20 reward should be paid out.\r\n    /// @dev Will fetch balanceOf to set the budget afterwards, can be used in case funds where sent manually to the escrow to sync the budget.\r\n    function partialPayment(uint256 _taskId, uint96[] calldata _partialNativeReward, uint88[] calldata _partialReward)\r\n        external;\r\n}\r\n"},"lib/trustless-actions/lib/smart-account/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/trustless-actions/lib/smart-account/src/modules/ISmartAccountModules.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISmartAccountModules {\n    /// @notice When no function exists for function called\n    error FunctionNotFound(bytes4 functionSelector);\n\n    /// @notice Module is added/updated/removed.\n    event ModuleSet(bytes4 functionSelector, address module);\n\n    /// @notice Set the currently registered module for function.\n    /// @dev Zero address means no module is registered.\n    function getModule(bytes4 functionSelector) external view returns (address module);\n}\n"},"lib/trustless-actions/lib/smart-account/src/modules/SmartAccountModulesLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SmartAccountERC165Lib} from \"./erc165/SmartAccountERC165Lib.sol\";\n\nimport {ISmartAccountModules} from \"./ISmartAccountModules.sol\";\n\n// Inspired by ERC-2535\nlibrary SmartAccountModulesLib {\n    bytes32 constant STORAGE_POSITION = keccak256(\"modules.smartaccount.plopmenz\");\n\n    struct Storage {\n        mapping(bytes4 functionSelector => address module) getFunction;\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /// @notice Sets the interfaces implemented by this contract to (un)supported.\n    function setInterfaces(bool supported) internal {\n        SmartAccountERC165Lib.setInterfaceSupport(type(ISmartAccountModules).interfaceId, supported);\n    }\n\n    /// @notice Installs all functions, interfaces, and performs storage initialization of this module.\n    function fullInstall(address module) internal {\n        setModule(ISmartAccountModules.getModule.selector, module);\n        setInterfaces(true);\n    }\n\n    /// @notice Uninstalls all functions and interfaces of this module.\n    function fullUninstall() internal {\n        setModule(ISmartAccountModules.getModule.selector, address(0));\n        setInterfaces(false);\n    }\n\n    /// @notice Get the currently registered module for function.\n    function getModule(bytes4 functionSelector) internal view returns (address module) {\n        return getStorage().getFunction[functionSelector];\n    }\n\n    /// @notice Set the currently registered module for function.\n    /// @dev Set to zero address to remove.\n    function setModule(bytes4 functionSelector, address module) internal {\n        getStorage().getFunction[functionSelector] = module;\n        emit ISmartAccountModules.ModuleSet(functionSelector, module);\n    }\n\n    /// @notice Delegates the current msg call to a module, if one is registered for that function.\n    function callModule() internal {\n        // Get module from function selector\n        address module = getModule(msg.sig);\n        if (module == address(0)) {\n            revert ISmartAccountModules.FunctionNotFound(msg.sig);\n        }\n        // Execute external function from module using delegatecall and return any value.\n        assembly {\n            // Copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // Execute function call using the module\n            let result := delegatecall(gas(), module, 0, calldatasize(), 0, 0)\n            // Get any return value\n            returndatacopy(0, 0, returndatasize())\n            // Return any return value or error back to the caller\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n"},"lib/trustless-actions/lib/smart-account/src/modules/erc165/ISmartAccountERC165.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC165} from \"../../../lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\";\n\ninterface ISmartAccountERC165 is IERC165 {\n    /// @notice Interface support changed.\n    event InterfaceSupportedChanged(bytes4 indexed interfaceId, bool supported);\n}\n"},"lib/trustless-actions/lib/smart-account/src/modules/erc165/SmartAccountERC165Lib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SmartAccountModulesLib} from \"../SmartAccountModulesLib.sol\";\n\nimport {ISmartAccountERC165, IERC165} from \"./ISmartAccountERC165.sol\";\n\nlibrary SmartAccountERC165Lib {\n    bytes32 constant STORAGE_POSITION = keccak256(\"erc165.modules.smartaccount.plopmenz\");\n\n    struct Storage {\n        mapping(bytes4 interfaceId => bool supported) getSupported;\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /// @notice Installs all functions, interfaces, and performs storage initialization of this module.\n    function fullInstall(address module) internal {\n        SmartAccountModulesLib.setModule(IERC165.supportsInterface.selector, module);\n    }\n\n    /// @notice Uninstalls all functions and interfaces of this module.\n    function fullUninstall() internal {\n        SmartAccountModulesLib.setModule(IERC165.supportsInterface.selector, address(0));\n    }\n\n    /// @notice Gets the interfaces supported by the Smart Account.\n    function supportsInterface(bytes4 interfaceId) internal view returns (bool supported) {\n        return getStorage().getSupported[interfaceId];\n    }\n\n    /// @notice Updates the interfaces supported by the Smart Account.\n    function setInterfaceSupport(bytes4 interfaceId, bool supported) internal {\n        getStorage().getSupported[interfaceId] = supported;\n        emit ISmartAccountERC165.InterfaceSupportedChanged(interfaceId, supported);\n    }\n}\n"},"lib/trustless-actions/lib/smart-account/src/modules/trustless-execution/ISmartAccountTrustlessExecution.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISmartAccountTrustlessExecution {\n    /// @notice The caller account is not authorized to perform an operation.\n    error NoExecutePermission(address account);\n\n    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.\n    error TooManyActions();\n\n    /// @notice Thrown if action execution has failed.\n    /// @param index The index of the action in the action array that failed.\n    error ActionFailed(uint256 index);\n\n    /// @notice Thrown if an action has insufficent gas left.\n    error InsufficientGas();\n\n    /// @notice A (new) account has become the owner of this contract.\n    event ExecutePermissionSet(address account, bool allowed);\n\n    /// @notice Emitted when an execution is performed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return execResults The array of results obtained from the executed actions in `bytes`.\n    /// @return failureMap The resulting failure map containing the actions have actually failed.\n    function execute(bytes32 _callId, Action[] memory _actions, uint256 _allowFailureMap)\n        external\n        returns (bytes[] memory execResults, uint256 failureMap);\n}\n"},"lib/trustless-actions/lib/smart-account/src/modules/trustless-execution/SmartAccountTrustlessExecutionLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {SmartAccountERC165Lib} from \"../erc165/SmartAccountERC165Lib.sol\";\nimport {SmartAccountModulesLib} from \"../SmartAccountModulesLib.sol\";\n\nimport {ISmartAccountTrustlessExecution} from \"./ISmartAccountTrustlessExecution.sol\";\n\nuint256 constant MAX_ACTIONS = 256;\n\nlibrary SmartAccountTrustlessExecutionLib {\n    bytes32 constant STORAGE_POSITION = keccak256(\"execution.trustless.modules.smartaccount.plopmenz\");\n\n    struct Storage {\n        mapping(address executor => bool allowed) executePermission;\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            s.slot := position\n        }\n    }\n\n    /// @notice Sets the interfaces implemented by this contract to (un)supported.\n    function setInterfaces(bool supported) internal {\n        SmartAccountERC165Lib.setInterfaceSupport(type(ISmartAccountTrustlessExecution).interfaceId, supported);\n    }\n\n    /// @notice Installs all functions, interfaces, and performs storage initialization of this module.\n    function fullInstall(address module) internal {\n        SmartAccountModulesLib.setModule(ISmartAccountTrustlessExecution.execute.selector, module);\n        setInterfaces(true);\n    }\n\n    /// @notice Uninstalls all functions and interfaces of this module.\n    function fullUninstall() internal {\n        SmartAccountModulesLib.setModule(ISmartAccountTrustlessExecution.execute.selector, address(0));\n        setInterfaces(false);\n    }\n\n    /// @notice Reverts if `account` is not allowed to execute actions for this smart account.\n    function ensureHasExecutePermission(address account) internal view {\n        if (!getStorage().executePermission[account]) {\n            revert ISmartAccountTrustlessExecution.NoExecutePermission(account);\n        }\n    }\n\n    /// @notice Sets if `account` is allowed to execute actions for this smart account.\n    function setExecutePermission(address account, bool allowed) internal {\n        getStorage().executePermission[account] = allowed;\n        emit ISmartAccountTrustlessExecution.ExecutePermissionSet(account, allowed);\n    }\n\n    /// Source: https://github.com/aragon/osx/blob/develop/packages/contracts/src/core/dao/DAO.sol\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return execResults The array of results obtained from the executed actions in `bytes`.\n    /// @return failureMap The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        ISmartAccountTrustlessExecution.Action[] calldata _actions,\n        uint256 _allowFailureMap\n    ) internal returns (bytes[] memory execResults, uint256 failureMap) {\n        ensureHasExecutePermission(msg.sender);\n\n        // Check that the action array length is within bounds.\n        if (_actions.length > MAX_ACTIONS) {\n            revert ISmartAccountTrustlessExecution.TooManyActions();\n        }\n\n        execResults = new bytes[](_actions.length);\n\n        uint256 gasBefore;\n        uint256 gasAfter;\n\n        for (uint256 i = 0; i < _actions.length;) {\n            gasBefore = gasleft();\n\n            (bool success, bytes memory result) = _actions[i].to.call{value: _actions[i].value}(_actions[i].data);\n            gasAfter = gasleft();\n\n            // Check if failure is allowed\n            if (!hasBit(_allowFailureMap, uint8(i))) {\n                // Check if the call failed.\n                if (!success) {\n                    revert ISmartAccountTrustlessExecution.ActionFailed(i);\n                }\n            } else {\n                // Check if the call failed.\n                if (!success) {\n                    // Make sure that the action call did not fail because 63/64 of `gasleft()` was insufficient to execute the external call `.to.call` (see [ERC-150](https://eips.ethereum.org/EIPS/eip-150)).\n                    // In specific scenarios, i.e. proposal execution where the last action in the action array is allowed to fail, the account calling `execute` could force-fail this action by setting a gas limit\n                    // where 63/64 is insufficient causing the `.to.call` to fail, but where the remaining 1/64 gas are sufficient to successfully finish the `execute` call.\n                    if (gasAfter < gasBefore / 64) {\n                        revert ISmartAccountTrustlessExecution.InsufficientGas();\n                    }\n\n                    // Store that this action failed.\n                    failureMap = flipBit(failureMap, uint8(i));\n                }\n            }\n\n            execResults[i] = result;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ISmartAccountTrustlessExecution.Executed({\n            actor: msg.sender,\n            callId: _callId,\n            actions: _actions,\n            allowFailureMap: _allowFailureMap,\n            failureMap: failureMap,\n            execResults: execResults\n        });\n    }\n\n    /// Source: https://github.com/aragon/osx-commons/blob/develop/contracts/src/utils/math/BitMap.sol\n    /// @param bitmap The `uint256` representation of bits.\n    /// @param index The index number to check whether 1 or 0 is set.\n    /// @return Returns `true` if the bit is set at `index` on `bitmap`.\n    function hasBit(uint256 bitmap, uint8 index) internal pure returns (bool) {\n        uint256 bitValue = bitmap & (1 << index);\n        return bitValue > 0;\n    }\n\n    /// Source: https://github.com/aragon/osx-commons/blob/develop/contracts/src/utils/math/BitMap.sol\n    /// @param bitmap The `uint256` representation of bits.\n    /// @param index The index number to set the bit.\n    /// @return Returns a new number in which the bit is set at `index`.\n    function flipBit(uint256 bitmap, uint8 index) internal pure returns (uint256) {\n        return bitmap ^ (1 << index);\n    }\n}\n"},"lib/trustless-actions/lib/trustless-management/lib/ens-reverse-claimable/src/ENSReverseClaimable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSReverseClaimable {\n    /// @notice ENS reverse name resolution is claimable by the owner of the contract.\n    function owner() external pure virtual returns (address) {\n        return 0xaF7E68bCb2Fc7295492A00177f14F59B92814e70; // plopmenz.eth\n    }\n}\n"},"lib/trustless-actions/lib/trustless-management/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/trustless-actions/lib/trustless-management/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/trustless-actions/lib/trustless-management/lib/osx-commons/contracts/src/dao/IDAO.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\n/// @title IDAO\n/// @author Aragon Association - 2022-2023\n/// @notice The interface required for DAOs within the Aragon App DAO framework.\n/// @custom:security-contact sirt@aragon.org\ninterface IDAO {\n    /// @notice The action struct to be consumed by the DAO's `execute` function resulting in an external call.\n    /// @param to The address to call.\n    /// @param value The native token value to be sent with the call.\n    /// @param data The bytes-encoded function selector and calldata for the call.\n    struct Action {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    /// @notice Checks if an address has permission on a contract via a permission identifier and considers if `ANY_ADDRESS` was used in the granting process.\n    /// @param _where The address of the contract.\n    /// @param _who The address of a EOA or contract to give the permissions.\n    /// @param _permissionId The permission identifier.\n    /// @param _data The optional data passed to the `PermissionCondition` registered.\n    /// @return Returns true if the address has permission, false if not.\n    function hasPermission(\n        address _where,\n        address _who,\n        bytes32 _permissionId,\n        bytes memory _data\n    ) external view returns (bool);\n\n    /// @notice Updates the DAO metadata (e.g., an IPFS hash).\n    /// @param _metadata The IPFS hash of the new metadata object.\n    function setMetadata(bytes calldata _metadata) external;\n\n    /// @notice Emitted when the DAO metadata is updated.\n    /// @param metadata The IPFS hash of the new metadata object.\n    event MetadataSet(bytes metadata);\n\n    /// @notice Executes a list of actions. If a zero allow-failure map is provided, a failing action reverts the entire execution. If a non-zero allow-failure map is provided, allowed actions can fail without the entire call being reverted.\n    /// @param _callId The ID of the call. The definition of the value of `callId` is up to the calling contract and can be used, e.g., as a nonce.\n    /// @param _actions The array of actions.\n    /// @param _allowFailureMap A bitmap allowing execution to succeed, even if individual actions might revert. If the bit at index `i` is 1, the execution succeeds even if the `i`th action reverts. A failure map value of 0 requires every action to not revert.\n    /// @return The array of results obtained from the executed actions in `bytes`.\n    /// @return The resulting failure map containing the actions have actually failed.\n    function execute(\n        bytes32 _callId,\n        Action[] memory _actions,\n        uint256 _allowFailureMap\n    ) external returns (bytes[] memory, uint256);\n\n    /// @notice Emitted when a proposal is executed.\n    /// @param actor The address of the caller.\n    /// @param callId The ID of the call.\n    /// @param actions The array of actions executed.\n    /// @param allowFailureMap The allow failure map encoding which actions are allowed to fail.\n    /// @param failureMap The failure map encoding which actions have failed.\n    /// @param execResults The array with the results of the executed actions.\n    /// @dev The value of `callId` is defined by the component/contract calling the execute function. A `Plugin` implementation can use it, for example, as a nonce.\n    event Executed(\n        address indexed actor,\n        bytes32 callId,\n        Action[] actions,\n        uint256 allowFailureMap,\n        uint256 failureMap,\n        bytes[] execResults\n    );\n\n    /// @notice Emitted when a standard callback is registered.\n    /// @param interfaceId The ID of the interface.\n    /// @param callbackSelector The selector of the callback function.\n    /// @param magicNumber The magic number to be registered for the callback function selector.\n    event StandardCallbackRegistered(\n        bytes4 interfaceId,\n        bytes4 callbackSelector,\n        bytes4 magicNumber\n    );\n\n    /// @notice Deposits (native) tokens to the DAO contract with a reference string.\n    /// @param _token The address of the token or address(0) in case of the native token.\n    /// @param _amount The amount of tokens to deposit.\n    /// @param _reference The reference describing the deposit reason.\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable;\n\n    /// @notice Emitted when a token deposit has been made to the DAO.\n    /// @param sender The address of the sender.\n    /// @param token The address of the deposited token.\n    /// @param amount The amount of tokens deposited.\n    /// @param _reference The reference describing the deposit reason.\n    event Deposited(\n        address indexed sender,\n        address indexed token,\n        uint256 amount,\n        string _reference\n    );\n\n    /// @notice Emitted when a native token deposit has been made to the DAO.\n    /// @dev This event is intended to be emitted in the `receive` function and is therefore bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).\n    /// @param sender The address of the sender.\n    /// @param amount The amount of native tokens deposited.\n    event NativeTokenDeposited(address sender, uint256 amount);\n\n    /// @notice Setter for the trusted forwarder verifying the meta transaction.\n    /// @param _trustedForwarder The trusted forwarder address.\n    function setTrustedForwarder(address _trustedForwarder) external;\n\n    /// @notice Getter for the trusted forwarder verifying the meta transaction.\n    /// @return The trusted forwarder address.\n    function getTrustedForwarder() external view returns (address);\n\n    /// @notice Emitted when a new TrustedForwarder is set on the DAO.\n    /// @param forwarder the new forwarder address.\n    event TrustedForwarderSet(address forwarder);\n\n    /// @notice Checks whether a signature is valid for a provided hash according to [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271).\n    /// @param _hash The hash of the data to be signed.\n    /// @param _signature The signature byte array associated with `_hash`.\n    /// @return Returns the `bytes4` magic value `0x1626ba7e` if the signature is valid and `0xffffffff` if not.\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external returns (bytes4);\n\n    /// @notice Registers an ERC standard having a callback by registering its [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.\n    /// @param _interfaceId The ID of the interface.\n    /// @param _callbackSelector The selector of the callback function.\n    /// @param _magicNumber The magic number to be registered for the function signature.\n    function registerStandardCallback(\n        bytes4 _interfaceId,\n        bytes4 _callbackSelector,\n        bytes4 _magicNumber\n    ) external;\n\n    /// @notice Removed function being left here to not corrupt the IDAO interface ID. Any call will revert.\n    /// @dev Introduced in v1.0.0. Removed in v1.4.0.\n    function setSignatureValidator(address) external;\n}\n"},"lib/trustless-actions/lib/trustless-management/src/IDAOExtensionWithAdmin.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAO} from \"../lib/osx-commons/contracts/src/dao/IDAO.sol\";\n\ninterface IDAOExtensionWithAdmin {\n    error SenderIsNotAdmin();\n\n    event AdminSet(IDAO indexed dao, address admin);\n\n    /// @notice Registers or updates the admin of a DAO. The admin has the permission to change permissions.\n    /// @param _dao The DAO this admin will control.\n    /// @param _admin The address that will control the DAO.\n    /// @dev If no admin is set, this can only be called by the DAO itself. When an admin is set, only the existing admin can update.\n    function setAdmin(IDAO _dao, address _admin) external;\n}\n"},"lib/trustless-actions/lib/trustless-management/src/IDAOManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOExtensionWithAdmin, IDAO} from \"./IDAOExtensionWithAdmin.sol\";\n\ninterface IDAOManager is IDAOExtensionWithAdmin {\n    error AccessDenied();\n\n    event Execution(\n        IDAO indexed dao,\n        uint256 indexed role,\n        address indexed sender,\n        IDAO.Action[] actions,\n        bytes[] returnValues,\n        uint256 failureMap\n    );\n\n    /// @notice Executes a list of actions as the DAO.\n    /// @param _dao Which DAO should execute the actions.\n    /// @param _role The role to use for validation if execution is allowed.\n    /// @param _actions The actions to execute.\n    /// @param _failureMap Which actions are allowed to fail without reverting the whole transaction.\n    /// @dev Only a single role means that a user satisfies multiple roles they might need to split their actions into multiple batches (one per role).\n    function asDAO(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions, uint256 _failureMap)\n        external\n        returns (bytes[] memory returnValues, uint256 failureMap);\n}\n"},"lib/trustless-actions/lib/trustless-management/src/IPermissionChecker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAO} from \"../lib/osx-commons/contracts/src/dao/IDAO.sol\";\n\ninterface IPermissionChecker {\n    /// @notice Additional external check if custom conditions are met.\n    /// @param _role The role to check permission for. (this could represent address / holding x amount of ERC20 tokens / ERC721 tokenId / ERC1155 tokenId)\n    /// @param _action The action to check.\n    function checkPermission(uint256 _role, IDAO.Action calldata _action) external view returns (bool);\n}\n"},"lib/trustless-actions/lib/trustless-management/src/ITrustlessManagement.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOManager, IDAO, IDAOExtensionWithAdmin} from \"./IDAOManager.sol\";\n\ninterface ITrustlessManagement is IDAOManager {\n    error SenderDoesNotHaveRole();\n\n    event FunctionBlacklistChanged(\n        IDAO indexed dao, uint256 indexed role, address zone, bytes4 functionSelector, address permissionChecker\n    );\n    event ZoneBlacklistChanged(IDAO indexed dao, uint256 indexed role, address zone, address permissionChecker);\n    event FullAccessChanged(IDAO indexed dao, uint256 indexed role, address permissionChecker);\n    event ZoneAccessChanged(IDAO indexed dao, uint256 indexed role, address zone, address permissionChecker);\n    event FunctionAccessChanged(\n        IDAO indexed dao, uint256 indexed role, address zone, bytes4 functionSelector, address permissionChecker\n    );\n\n    /// @notice A container for all info related to a certain DAO.\n    /// @param admin The address that can change the permissions for this DAO.\n    /// @param permissions The permissions set for this DAO.\n    /// @dev Admin as zero address / unset means that the DAO will be the admin itself.\n    struct DAOInfo {\n        address admin;\n        mapping(uint256 role => PermissionInfo permission) permissions;\n    }\n\n    /// @notice A container for all info related to the permissions of a certain role.\n    /// @param fullAccess This role has access to perform any actions, the address referes to a permissionChecker that can be used to impose restrictions.\n    /// @param zoneAccess This role has access to perform any actions, as long as its with a certain smart contract address (zone).\n    /// @param zoneBlacklist This role is prevented to perform any actions with a certain smart contract address (zone).\n    /// @param functionAccess This role has access to call a specific function (functionSelector) of a certain smart contract address (zone).\n    /// @param functionBlacklist This role is prevented to call a specific function (functionSelector) of a certain smart contract address (zone).\n    /// @dev In case you dont need to use any permissionChecker, you can set the address to NO_PERMISSION_CHECKER = address(type(uint160).max).\n    /// @dev In case you want to revoke the permission, you can set the permissionChecker back to default REVOKE = address(0).\n    /// @dev FunctionIds are encoded as (uint160(bytes20(_zone)) << 32) + uint32(_functionSelector).\n    struct PermissionInfo {\n        address fullAccess;\n        mapping(address zone => address permissionChecker) zoneAccess;\n        mapping(address zone => address permissionChecker) zoneBlacklist;\n        mapping(uint256 functionId => address permissionChecker) functionAccess;\n        mapping(uint256 functionId => address permissionChecker) functionBlacklist;\n    }\n\n    /// @notice Verifies if an address has/satisfies a certain role.\n    /// @param _account The address to check.\n    /// @param _roleId The role to check.\n    function hasRole(address _account, uint256 _roleId) external view returns (bool);\n\n    /// @notice Verifies if a role is allowed to execute a list of actions.\n    /// @param _dao The DAO to check permissions of.\n    /// @param _role The role to check permission for.\n    /// @param _actions The actions to check.\n    /// @dev Only a single role means that a user satisfies multiple roles they might need to split their actions into multiple batches (one per role).\n    function isAllowed(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions) external view returns (bool);\n\n    /// @notice Grants/Revokes a role the permission to do any action (if not blacklisted).\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is granted/revoked the permission.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    function changeFullAccess(IDAO _dao, uint256 _role, address _permissionChecker) external;\n\n    /// @notice Grants/Revokes a role the permission to call all functions of one smart contract (if not blacklisted).\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is granted/revoked the permission.\n    /// @param _zone The address of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    function changeZoneAccess(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external;\n\n    /// @notice Adds to / Removes from a blacklist preventing a role from calling one function of one smart contract.\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is added to / removed from this blacklist.\n    /// @param _zone The address of the smart contract.\n    /// @param _functionSelector The function selector of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    /// @dev This takes priority no matter what access (full/zone/function) the role has.\n    function changeFunctionBlacklist(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external;\n\n    /// @notice Grants/Revokes a role the permission to call one function of one smart contract (if not blacklisted).\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is granted/revoked the permission.\n    /// @param _zone The address of the smart contract.\n    /// @param _functionSelector The function selector of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    function changeFunctionAccess(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external;\n\n    /// @notice Adds to / Removes from a blacklist preventing a role from calling any function of one smart contract.\n    /// @param _dao The DAO that will have the permission change.\n    /// @param _role The role that is added to / removed from this blacklist.\n    /// @param _zone The address of the smart contract.\n    /// @param _permissionChecker ZeroAddress for always off, FullAddress (0xFFF...FFF) for always on. Can be the address of IPermissionChecker smart contract for a custom condition check.\n    /// @dev This takes priority no matter what access (full/zone/function) the role has.\n    function changeZoneBlacklist(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external;\n}\n"},"lib/trustless-actions/lib/trustless-management/src/TrustlessManagement.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC165} from \"../lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\";\nimport {ENSReverseClaimable} from \"../lib/ens-reverse-claimable/src/ENSReverseClaimable.sol\";\n\nimport {IPermissionChecker} from \"./IPermissionChecker.sol\";\nimport {ITrustlessManagement, IDAOManager, IDAO, IDAOExtensionWithAdmin} from \"./ITrustlessManagement.sol\";\n\naddress constant NO_PERMISSION_CHECKER = address(type(uint160).max);\nbytes32 constant EXECUTION_ID = keccak256(\"TRUSTLESS_MANAGEMENT\");\n\nabstract contract TrustlessManagement is ERC165, ENSReverseClaimable, ITrustlessManagement {\n    mapping(IDAO dao => DAOInfo info) private daoInfo;\n\n    /// @inheritdoc ERC165\n    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\n        return _interfaceId == type(ITrustlessManagement).interfaceId || super.supportsInterface(_interfaceId);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function hasRole(address _account, uint256 _roleId) public view virtual returns (bool);\n\n    /// @inheritdoc ITrustlessManagement\n    function isAllowed(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions) public view returns (bool) {\n        PermissionInfo storage permissions = daoInfo[_dao].permissions[_role];\n\n        for (uint256 i; i < _actions.length;) {\n            uint256 functionId = _functionId(_actions[i].to, bytes4(_actions[i].data));\n            if (\n                _checkPermission(permissions.functionBlacklist[functionId], _role, _actions[i])\n                    || _checkPermission(permissions.zoneBlacklist[_actions[i].to], _role, _actions[i])\n            ) {\n                // Blacklisted\n                return false;\n            }\n\n            if (\n                !_checkPermission(permissions.fullAccess, _role, _actions[i])\n                    && !_checkPermission(permissions.zoneAccess[_actions[i].to], _role, _actions[i])\n                    && !_checkPermission(permissions.functionAccess[functionId], _role, _actions[i])\n            ) {\n                // Permission not granted\n                return false;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // No action rejected => allowed\n        return true;\n    }\n\n    /// @inheritdoc IDAOManager\n    function asDAO(IDAO _dao, uint256 _role, IDAO.Action[] calldata _actions, uint256 _failureMap)\n        external\n        returns (bytes[] memory returnValues, uint256 failureMap)\n    {\n        if (!hasRole(msg.sender, _role)) {\n            revert SenderDoesNotHaveRole();\n        }\n        if (!isAllowed(_dao, _role, _actions)) {\n            revert AccessDenied();\n        }\n\n        (returnValues, failureMap) = _dao.execute(EXECUTION_ID, _actions, _failureMap);\n        emit Execution(_dao, _role, msg.sender, _actions, returnValues, failureMap);\n    }\n\n    /// @inheritdoc IDAOExtensionWithAdmin\n    function setAdmin(IDAO _dao, address _admin) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.admin = _admin;\n        emit AdminSet(_dao, _admin);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeFullAccess(IDAO _dao, uint256 _role, address _permissionChecker) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].fullAccess = _permissionChecker;\n        emit FullAccessChanged(_dao, _role, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeZoneAccess(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].zoneAccess[_zone] = _permissionChecker;\n        emit ZoneAccessChanged(_dao, _role, _zone, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeZoneBlacklist(IDAO _dao, uint256 _role, address _zone, address _permissionChecker) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].zoneBlacklist[_zone] = _permissionChecker;\n        emit ZoneBlacklistChanged(_dao, _role, _zone, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeFunctionAccess(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].functionAccess[_functionId(_zone, _functionSelector)] = _permissionChecker;\n        emit FunctionAccessChanged(_dao, _role, _zone, _functionSelector, _permissionChecker);\n    }\n\n    /// @inheritdoc ITrustlessManagement\n    function changeFunctionBlacklist(\n        IDAO _dao,\n        uint256 _role,\n        address _zone,\n        bytes4 _functionSelector,\n        address _permissionChecker\n    ) external {\n        DAOInfo storage info = daoInfo[_dao];\n        _ensureSenderIsAdmin(_dao, info.admin);\n        info.permissions[_role].functionBlacklist[_functionId(_zone, _functionSelector)] = _permissionChecker;\n        emit FunctionBlacklistChanged(_dao, _role, _zone, _functionSelector, _permissionChecker);\n    }\n\n    function _checkPermission(address _permissionChecker, uint256 _role, IDAO.Action calldata _action)\n        internal\n        view\n        returns (bool)\n    {\n        if (_permissionChecker == address(0)) {\n            // Permission not granted\n            return false;\n        }\n        if (_permissionChecker == NO_PERMISSION_CHECKER) {\n            // Permission always granted\n            return true;\n        }\n\n        // Additional check\n        return IPermissionChecker(_permissionChecker).checkPermission(_role, _action);\n    }\n\n    // address + function selector\n    function _functionId(address _zone, bytes4 _functionSelector) internal pure returns (uint256) {\n        return (uint160(bytes20(_zone)) << 32) + uint32(_functionSelector);\n    }\n\n    function _ensureSenderIsAdmin(IDAO _dao, address _admin) internal view {\n        if (_admin == address(0)) {\n            // Admin not set means DAO is the admin\n            if (msg.sender != address(_dao)) {\n                revert SenderIsNotAdmin();\n            }\n        } else {\n            // Specific admin will only be allowed. DAO is not allowed to change permissions. (for example: if it is a SubDAO)\n            if (msg.sender != _admin) {\n                revert SenderIsNotAdmin();\n            }\n        }\n    }\n}\n"},"lib/trustless-actions/src/ITrustlessActions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAOManager, IDAO} from \"../lib/trustless-management/src/IDAOManager.sol\";\n\ninterface ITrustlessActions {\n    error RequestDoesNotExist();\n    error RequestAlreadyExecuted();\n\n    event ActionCreated(\n        uint32 indexed id,\n        IDAO indexed dao,\n        IDAOManager manager,\n        uint256 role,\n        IDAO.Action[] actions,\n        uint256 failureMap,\n        string metadata\n    );\n    event ActionExecuted(\n        uint32 indexed id, IDAO indexed dao, address indexed executor, bytes[] returnValues, uint256 failureMap\n    );\n\n    /// @notice A container for multiple requests.\n    /// @param requestCount How many proposed actions have been created.\n    /// @param getRequest The proposed actions to be executed.\n    struct ActionRequests {\n        uint32 requestCount;\n        mapping(uint32 id => ActionRequest request) getRequest;\n    }\n\n    /// @notice A container for all info related to an execute action request.\n    /// @param executed If the action has been executed.\n    /// @param manager The management contract to use for the execution.\n    /// @param role The role to use for the execution.\n    /// @param actions The actions to execute.\n    /// @param failureMap Which actions are allowed to fail without reverting the transaction.\n    struct ActionRequest {\n        bool executed;\n        IDAOManager manager;\n        uint256 role;\n        IDAO.Action[] actions;\n        uint256 failureMap;\n    }\n\n    /// @notice Gets a certain action request.\n    /// @param _dao The DAO that has the request.\n    /// @param _id The id of the request.\n    function getAction(IDAO _dao, uint32 _id) external view returns (ActionRequest memory request);\n\n    /// @notice Creates a request to execute certain actions.\n    /// @param _manager The management contract to use for performing the actions.\n    /// @param _role The role of the management contract to use for performing the actions.\n    /// @param _actions The actions that are proposed to be executed.\n    /// @param _failureMap The actions that are allowed to be revert.\n    /// @param _metadata Additional info from the creator.\n    /// @dev The sender should be the DAO (utilizing a management solution).\n    function createAction(\n        IDAOManager _manager,\n        uint256 _role,\n        IDAO.Action[] calldata _actions,\n        uint256 _failureMap,\n        string calldata _metadata\n    ) external returns (uint32 id);\n\n    /// @notice Executes a certain action request.\n    /// @param _dao The DAO that has the request.\n    /// @param _id The id of the request.\n    /// @dev This is only possible if the request has not been executed yet and the conditions of the TrustlessActions implementation are met.\n    function executeAction(IDAO _dao, uint32 _id) external returns (bytes[] memory returnValues, uint256 failureMap);\n}\n"},"lib/trustless-actions/src/extensions/IPaidAction.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDAO} from \"../../lib/trustless-management/src/IDAOManager.sol\";\n\ninterface IPaidAction {\n    error Underpaying();\n    error TransferToDAOFailed();\n\n    /// @notice A container for all settings related to a certain DAO.\n    /// @param cost How much native currency should be paid to be allowed to create an action.\n    struct PaidDaoSettings {\n        uint256 cost;\n    }\n\n    /// @notice The cost of a certain DAO.\n    function getCost(IDAO _dao) external view returns (uint256 cost);\n\n    /// @notice Updates the cost. The sender should be the DAO that wants to update.\n    /// @param _cost The new cost.\n    function updateCost(uint256 _cost) external;\n}\n"},"lib/trustless-actions/src/smart-account-installers/SmartAccountPaidActionInstaller.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    SmartAccountTrustlessExecutionLib,\n    ISmartAccountTrustlessExecution\n} from \"../../lib/smart-account/src/modules/trustless-execution/SmartAccountTrustlessExecutionLib.sol\";\n\nimport {\n    ITrustlessManagement,\n    IDAO,\n    NO_PERMISSION_CHECKER\n} from \"../../lib/trustless-management/src/TrustlessManagement.sol\";\n\nimport {ITrustlessActions} from \"../ITrustlessActions.sol\";\nimport {IPaidAction} from \"../extensions/IPaidAction.sol\";\n\nabstract contract SmartAccountPaidActionInstaller {\n    /// @notice The smart account module to add execute, which is needed to use trustless management.\n    ISmartAccountTrustlessExecution public immutable smartAccountTrustlessExecution;\n\n    /// @notice Address trustless management (for creating and executing trustless actions).\n    ITrustlessManagement public immutable addressTrustlessManagement;\n\n    /// @notice The trustless actions implementation.\n    ITrustlessActions public immutable trustlessActions;\n\n    /// @notice The paid action contract.\n    IPaidAction public immutable paidAction;\n\n    constructor(\n        ISmartAccountTrustlessExecution _smartAccountTrustlessExecution,\n        ITrustlessManagement _addressTrustlessManagement,\n        ITrustlessActions _trustlessActions,\n        IPaidAction _paidAction\n    ) {\n        smartAccountTrustlessExecution = _smartAccountTrustlessExecution;\n        addressTrustlessManagement = _addressTrustlessManagement;\n        trustlessActions = _trustlessActions;\n        paidAction = _paidAction;\n    }\n\n    /// @notice Installs Trustless Exeuction module in the smart account, grants the address trustless management permission and performs the permissionsInstall.\n    /// @param _cost How much native currency someone has to pay to perform the paid action.\n    function fullInstall(uint256 _cost) public virtual {\n        // Install smart account module\n        SmartAccountTrustlessExecutionLib.fullInstall(address(smartAccountTrustlessExecution));\n\n        // Enable trustless management (give execute permission).\n        SmartAccountTrustlessExecutionLib.setExecutePermission(address(addressTrustlessManagement), true);\n\n        permissionsInstall(_cost);\n    }\n\n    /// @notice If Trustless Execution module is already installed and address trustless management is enabled, this will skip those installation steps.\n    /// @param _cost How much native currency someone has to pay to perform the paid action.\n    function permissionsInstall(uint256 _cost) public virtual {\n        // Grants trustless management permissions and cost.\n        if (_cost != 0) {\n            paidAction.updateCost(_cost);\n        }\n        addressTrustlessManagement.changeFunctionAccess(\n            IDAO(address(this)),\n            uint160(address(paidAction)),\n            address(trustlessActions),\n            trustlessActions.createAction.selector,\n            NO_PERMISSION_CHECKER\n        );\n\n        grantPermissions();\n    }\n\n    /// @notice Uninstalls Trustless Exeuction module in the smart account, revokes the address trustless management permission and performs the permissionsUninstall.\n    function fullUninstall() public virtual {\n        // Install smart account module\n        SmartAccountTrustlessExecutionLib.fullUninstall();\n\n        // Enable trustless management (give execute permission).\n        SmartAccountTrustlessExecutionLib.setExecutePermission(address(addressTrustlessManagement), false);\n\n        permissionsUninstall();\n    }\n\n    /// @notice If Trustless Execution module is already installed and address trustless management is enabled, this will skip those installation steps.\n    function permissionsUninstall() public virtual {\n        // Revokes trustless management permissions\n        // Cost is not updated, as the contract itself cannot create action anymore anyhow, it will be overwritten on the next install\n        addressTrustlessManagement.changeFunctionAccess(\n            IDAO(address(this)),\n            uint160(address(paidAction)),\n            address(trustlessActions),\n            trustlessActions.createAction.selector,\n            address(0)\n        );\n\n        revokePermissions();\n    }\n\n    function grantPermissions() internal virtual;\n\n    function revokePermissions() internal virtual;\n\n    function grantZoneAccess(address _zone) internal {\n        addressTrustlessManagement.changeZoneAccess(\n            IDAO(address(this)), uint160(address(trustlessActions)), _zone, NO_PERMISSION_CHECKER\n        );\n    }\n\n    function grantFunctionAccess(address _zone, bytes4 _functionSelector) internal {\n        addressTrustlessManagement.changeFunctionAccess(\n            IDAO(address(this)), uint160(address(trustlessActions)), _zone, _functionSelector, NO_PERMISSION_CHECKER\n        );\n    }\n\n    function revokeZoneAccess(address _zone) internal {\n        addressTrustlessManagement.changeZoneAccess(\n            IDAO(address(this)), uint160(address(trustlessActions)), _zone, address(0)\n        );\n    }\n\n    function revokeFunctionAccess(address _zone, bytes4 _functionSelector) internal {\n        addressTrustlessManagement.changeFunctionAccess(\n            IDAO(address(this)), uint160(address(trustlessActions)), _zone, _functionSelector, address(0)\n        );\n    }\n}\n"},"src/TaskDisputes/SmartAccountTaskDisputeInstaller.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {\n    SmartAccountPaidActionInstaller,\n    ISmartAccountTrustlessExecution,\n    ITrustlessManagement,\n    ITrustlessActions,\n    IPaidAction\n} from \"../../lib/trustless-actions/src/smart-account-installers/SmartAccountPaidActionInstaller.sol\";\n\nimport {ITasks} from \"../../lib/openrd-foundry/src/ITasks.sol\";\n\ncontract SmartAccountTaskDisputeInstaller is SmartAccountPaidActionInstaller {\n    ITasks public immutable tasks;\n\n    constructor(\n        ISmartAccountTrustlessExecution _smartAccountTrustlessExecution,\n        ITrustlessManagement _addressTrustlessManagement,\n        ITrustlessActions _trustlessActions,\n        IPaidAction _taskDisputes,\n        ITasks _tasks\n    )\n        SmartAccountPaidActionInstaller(\n            _smartAccountTrustlessExecution,\n            _addressTrustlessManagement,\n            _trustlessActions,\n            _taskDisputes\n        )\n    {\n        tasks = _tasks;\n    }\n\n    function grantPermissions() internal override {\n        grantFunctionAccess(address(tasks), tasks.completeByDispute.selector);\n    }\n\n    function revokePermissions() internal override {\n        revokeFunctionAccess(address(tasks), tasks.completeByDispute.selector);\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/trustless-actions/lib/openzeppelin-contracts/contracts/","ds-test/=lib/trustless-actions/lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","ens-reverse-claimable/=lib/openmesh-admin/lib/ens-reverse-claimable/src/","erc4626-tests/=lib/trustless-actions/lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openmesh-admin/=lib/openmesh-admin/src/","openrd-foundry/=lib/openrd-foundry/src/","openzeppelin-contracts/=lib/trustless-actions/lib/openzeppelin-contracts/","osx-commons/=lib/trustless-actions/lib/trustless-management/lib/osx-commons/","smart-account/=lib/openmesh-admin/lib/smart-account/src/","tag-manager/=lib/trustless-actions/lib/trustless-management/lib/tag-manager/src/","trustless-actions/=lib/trustless-actions/src/","trustless-management/=lib/trustless-actions/lib/trustless-management/src/"],"optimizer":{"enabled":true,"runs":200},"evmVersion":"shanghai","viaIR":true},"metadata":{"useLiteralContent":true}},"license":"MIT"},"source":"/home/plopmenz/openmesh-smart-contracts/lib/openrd-dao-extensions","submitted":{"transactionHash":"0xf19d5647712edf219b70cf3cb8f95d17e18b27cfc6996cf69be85e8b19d07db0","date":"2024-04-15T18:27:11.144Z"}}